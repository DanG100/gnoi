// Code generated by protoc-gen-go.
// source: optical/optical.proto
// DO NOT EDIT!

/*
Package gnoi_optical is a generated protocol buffer package.

It is generated from these files:
	optical/optical.proto

It has these top-level messages:
	OTDRRequest
	OTDRConfigurationProfile
	OTDRConfiguration
	OTDRResponse
	OTDRTrace
	Event
*/
package gnoi_optical

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import gnoi_types "github.com/openconfig/gnoi/types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Type definition for different profiles of fiber types. These match what is
// already defined in OpenConfig under the FIBER_TYPE_PROFILE identityref in
// openconfig-optical-amplifier.yang model.
type FiberTypeProfile int32

const (
	FiberTypeProfile_FTP_UNKNOWN   FiberTypeProfile = 0
	FiberTypeProfile_FTP_DSF       FiberTypeProfile = 1
	FiberTypeProfile_FTP_LEAF      FiberTypeProfile = 2
	FiberTypeProfile_FTP_SSMF      FiberTypeProfile = 3
	FiberTypeProfile_FTP_TWC       FiberTypeProfile = 4
	FiberTypeProfile_FTP_TWRS      FiberTypeProfile = 5
	FiberTypeProfile_FTP_LS        FiberTypeProfile = 6
	FiberTypeProfile_FTP_TERAWAVE  FiberTypeProfile = 7
	FiberTypeProfile_FTP_TERALIGHT FiberTypeProfile = 8
)

var FiberTypeProfile_name = map[int32]string{
	0: "FTP_UNKNOWN",
	1: "FTP_DSF",
	2: "FTP_LEAF",
	3: "FTP_SSMF",
	4: "FTP_TWC",
	5: "FTP_TWRS",
	6: "FTP_LS",
	7: "FTP_TERAWAVE",
	8: "FTP_TERALIGHT",
}
var FiberTypeProfile_value = map[string]int32{
	"FTP_UNKNOWN":   0,
	"FTP_DSF":       1,
	"FTP_LEAF":      2,
	"FTP_SSMF":      3,
	"FTP_TWC":       4,
	"FTP_TWRS":      5,
	"FTP_LS":        6,
	"FTP_TERAWAVE":  7,
	"FTP_TERALIGHT": 8,
}

func (x FiberTypeProfile) String() string {
	return proto.EnumName(FiberTypeProfile_name, int32(x))
}
func (FiberTypeProfile) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type OTDRRequest_OTDRResultsMethod int32

const (
	OTDRRequest_RESULTS_UNKNOWN       OTDRRequest_OTDRResultsMethod = 0
	OTDRRequest_RESULTS_TO_LOCAL_DISK OTDRRequest_OTDRResultsMethod = 1
	OTDRRequest_RESULTS_IN_RESPONSE   OTDRRequest_OTDRResultsMethod = 2
)

var OTDRRequest_OTDRResultsMethod_name = map[int32]string{
	0: "RESULTS_UNKNOWN",
	1: "RESULTS_TO_LOCAL_DISK",
	2: "RESULTS_IN_RESPONSE",
}
var OTDRRequest_OTDRResultsMethod_value = map[string]int32{
	"RESULTS_UNKNOWN":       0,
	"RESULTS_TO_LOCAL_DISK": 1,
	"RESULTS_IN_RESPONSE":   2,
}

func (x OTDRRequest_OTDRResultsMethod) String() string {
	return proto.EnumName(OTDRRequest_OTDRResultsMethod_name, int32(x))
}
func (OTDRRequest_OTDRResultsMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0}
}

type OTDRResponse_OTDRState int32

const (
	OTDRResponse_UNKNOWN  OTDRResponse_OTDRState = 0
	OTDRResponse_RUNNING  OTDRResponse_OTDRState = 1
	OTDRResponse_PENDING  OTDRResponse_OTDRState = 2
	OTDRResponse_COMPLETE OTDRResponse_OTDRState = 3
)

var OTDRResponse_OTDRState_name = map[int32]string{
	0: "UNKNOWN",
	1: "RUNNING",
	2: "PENDING",
	3: "COMPLETE",
}
var OTDRResponse_OTDRState_value = map[string]int32{
	"UNKNOWN":  0,
	"RUNNING":  1,
	"PENDING":  2,
	"COMPLETE": 3,
}

func (x OTDRResponse_OTDRState) String() string {
	return proto.EnumName(OTDRResponse_OTDRState_name, int32(x))
}
func (OTDRResponse_OTDRState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type OTDRRequest struct {
	// Absolute path to the /components/component list member in the OpenConfig
	// model corresponding to the port to perform the OTDR trace from.
	// (e.g., /components/component[name=otdr-1-1])
	Component *gnoi_types.Path `protobuf:"bytes,1,opt,name=component" json:"component,omitempty"`
	// Describes how the results of the OTDR trace should be made available. More
	// than one option may be specified if desired.
	ResultsMethod []OTDRRequest_OTDRResultsMethod `protobuf:"varint,2,rep,packed,name=results_method,json=resultsMethod,enum=gnoi.optical.OTDRRequest_OTDRResultsMethod" json:"results_method,omitempty"`
	// Describes the configuration used to perform an OTDR trace for the needed
	// circumstance.
	Configuration *OTDRConfigurationProfile `protobuf:"bytes,3,opt,name=configuration" json:"configuration,omitempty"`
	// If specified, the device will label the OTDR trace so it can be recalled
	// later. For example, the initial OTDR trace measured during span
	// commissioning might be labeled "baseline".
	Label string `protobuf:"bytes,4,opt,name=label" json:"label,omitempty"`
}

func (m *OTDRRequest) Reset()                    { *m = OTDRRequest{} }
func (m *OTDRRequest) String() string            { return proto.CompactTextString(m) }
func (*OTDRRequest) ProtoMessage()               {}
func (*OTDRRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *OTDRRequest) GetComponent() *gnoi_types.Path {
	if m != nil {
		return m.Component
	}
	return nil
}

func (m *OTDRRequest) GetConfiguration() *OTDRConfigurationProfile {
	if m != nil {
		return m.Configuration
	}
	return nil
}

type OTDRConfigurationProfile struct {
	// Types that are valid to be assigned to ProfileType:
	//	*OTDRConfigurationProfile_CustomProfile
	//	*OTDRConfigurationProfile_Profile
	ProfileType isOTDRConfigurationProfile_ProfileType `protobuf_oneof:"profile_type"`
}

func (m *OTDRConfigurationProfile) Reset()                    { *m = OTDRConfigurationProfile{} }
func (m *OTDRConfigurationProfile) String() string            { return proto.CompactTextString(m) }
func (*OTDRConfigurationProfile) ProtoMessage()               {}
func (*OTDRConfigurationProfile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isOTDRConfigurationProfile_ProfileType interface {
	isOTDRConfigurationProfile_ProfileType()
}

type OTDRConfigurationProfile_CustomProfile struct {
	CustomProfile string `protobuf:"bytes,1,opt,name=custom_profile,json=customProfile,oneof"`
}
type OTDRConfigurationProfile_Profile struct {
	Profile *OTDRConfiguration `protobuf:"bytes,2,opt,name=profile,oneof"`
}

func (*OTDRConfigurationProfile_CustomProfile) isOTDRConfigurationProfile_ProfileType() {}
func (*OTDRConfigurationProfile_Profile) isOTDRConfigurationProfile_ProfileType()       {}

func (m *OTDRConfigurationProfile) GetProfileType() isOTDRConfigurationProfile_ProfileType {
	if m != nil {
		return m.ProfileType
	}
	return nil
}

func (m *OTDRConfigurationProfile) GetCustomProfile() string {
	if x, ok := m.GetProfileType().(*OTDRConfigurationProfile_CustomProfile); ok {
		return x.CustomProfile
	}
	return ""
}

func (m *OTDRConfigurationProfile) GetProfile() *OTDRConfiguration {
	if x, ok := m.GetProfileType().(*OTDRConfigurationProfile_Profile); ok {
		return x.Profile
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OTDRConfigurationProfile) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OTDRConfigurationProfile_OneofMarshaler, _OTDRConfigurationProfile_OneofUnmarshaler, _OTDRConfigurationProfile_OneofSizer, []interface{}{
		(*OTDRConfigurationProfile_CustomProfile)(nil),
		(*OTDRConfigurationProfile_Profile)(nil),
	}
}

func _OTDRConfigurationProfile_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OTDRConfigurationProfile)
	// profile_type
	switch x := m.ProfileType.(type) {
	case *OTDRConfigurationProfile_CustomProfile:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.CustomProfile)
	case *OTDRConfigurationProfile_Profile:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Profile); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("OTDRConfigurationProfile.ProfileType has unexpected type %T", x)
	}
	return nil
}

func _OTDRConfigurationProfile_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OTDRConfigurationProfile)
	switch tag {
	case 1: // profile_type.custom_profile
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ProfileType = &OTDRConfigurationProfile_CustomProfile{x}
		return true, err
	case 2: // profile_type.profile
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OTDRConfiguration)
		err := b.DecodeMessage(msg)
		m.ProfileType = &OTDRConfigurationProfile_Profile{msg}
		return true, err
	default:
		return false, nil
	}
}

func _OTDRConfigurationProfile_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OTDRConfigurationProfile)
	// profile_type
	switch x := m.ProfileType.(type) {
	case *OTDRConfigurationProfile_CustomProfile:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.CustomProfile)))
		n += len(x.CustomProfile)
	case *OTDRConfigurationProfile_Profile:
		s := proto.Size(x.Profile)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// OTDR configuration options which can be set on the device. It is not required
// that every field be set as some fields may not apply for a given
// implementation.
type OTDRConfiguration struct {
	// The time in seconds in which the OTDR trace will run continuously to
	// collect data.
	AcquisitionTimeS uint32 `protobuf:"varint,1,opt,name=acquisition_time_s,json=acquisitionTimeS" json:"acquisition_time_s,omitempty"`
	// The pulse width in nanoseconds which defines how long pulses sent by the
	// OTDR will be during the test.
	PulseWidthNs float32 `protobuf:"fixed32,2,opt,name=pulse_width_ns,json=pulseWidthNs" json:"pulse_width_ns,omitempty"`
	// The wavelength in MHz that will be sent by the OTDR. This may be left blank
	// if the OTDR only supports one wavelength.
	WavelengthMhz uint64 `protobuf:"varint,3,opt,name=wavelength_mhz,json=wavelengthMhz" json:"wavelength_mhz,omitempty"`
	// The maximum fiber distance range in meters that the OTDR trace will
	// support.
	RangeM float32 `protobuf:"fixed32,4,opt,name=range_m,json=rangeM" json:"range_m,omitempty"`
	// The type of fiber that is being measured.
	FiberType FiberTypeProfile `protobuf:"varint,5,opt,name=fiber_type,json=fiberType,enum=gnoi.optical.FiberTypeProfile" json:"fiber_type,omitempty"`
}

func (m *OTDRConfiguration) Reset()                    { *m = OTDRConfiguration{} }
func (m *OTDRConfiguration) String() string            { return proto.CompactTextString(m) }
func (*OTDRConfiguration) ProtoMessage()               {}
func (*OTDRConfiguration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type OTDRResponse struct {
	// The local path in which the OTDR file is saved on the device.
	LocalPath string `protobuf:"bytes,1,opt,name=local_path,json=localPath" json:"local_path,omitempty"`
	// The OTDR trace details in a structured format.
	OtdrTrace *OTDRTrace `protobuf:"bytes,2,opt,name=otdr_trace,json=otdrTrace" json:"otdr_trace,omitempty"`
	// The state of the OTDR trace requested. Note that this does not include
	// error states as these should be returned as a gRPC error.
	State OTDRResponse_OTDRState `protobuf:"varint,3,opt,name=state,enum=gnoi.optical.OTDRResponse_OTDRState" json:"state,omitempty"`
}

func (m *OTDRResponse) Reset()                    { *m = OTDRResponse{} }
func (m *OTDRResponse) String() string            { return proto.CompactTextString(m) }
func (*OTDRResponse) ProtoMessage()               {}
func (*OTDRResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *OTDRResponse) GetOtdrTrace() *OTDRTrace {
	if m != nil {
		return m.OtdrTrace
	}
	return nil
}

type OTDRTrace struct {
	// Total measured loss of the fiber.
	TotalLossDb float32 `protobuf:"fixed32,1,opt,name=total_loss_db,json=totalLossDb" json:"total_loss_db,omitempty"`
	// Total measured length of the fiber in meters.
	TotalLengthM float32 `protobuf:"fixed32,2,opt,name=total_length_m,json=totalLengthM" json:"total_length_m,omitempty"`
	// Optical return loss of the fiber in dB.
	OpticalReturnLossDb float32 `protobuf:"fixed32,3,opt,name=optical_return_loss_db,json=opticalReturnLossDb" json:"optical_return_loss_db,omitempty"`
	// Average fiber loss (dB/km)
	AverageLossDbKm float32 `protobuf:"fixed32,4,opt,name=average_loss_db_km,json=averageLossDbKm" json:"average_loss_db_km,omitempty"`
	// Discovered fiber type, if the OTDR can infer this information.
	DiscoveredFiberType FiberTypeProfile `protobuf:"varint,5,opt,name=discovered_fiber_type,json=discoveredFiberType,enum=gnoi.optical.FiberTypeProfile" json:"discovered_fiber_type,omitempty"`
	Events              []*Event         `protobuf:"bytes,6,rep,name=events" json:"events,omitempty"`
}

func (m *OTDRTrace) Reset()                    { *m = OTDRTrace{} }
func (m *OTDRTrace) String() string            { return proto.CompactTextString(m) }
func (*OTDRTrace) ProtoMessage()               {}
func (*OTDRTrace) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *OTDRTrace) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

type Event struct {
	// Distance at which the event occurred in meters.
	DistanceM float32 `protobuf:"fixed32,1,opt,name=distance_m,json=distanceM" json:"distance_m,omitempty"`
	// The fiber loss that occurred at the event in dB.
	LossDb float32 `protobuf:"fixed32,2,opt,name=loss_db,json=lossDb" json:"loss_db,omitempty"`
	// The reflection that occurred at the event in dB.
	ReflectionDb float32 `protobuf:"fixed32,3,opt,name=reflection_db,json=reflectionDb" json:"reflection_db,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func init() {
	proto.RegisterType((*OTDRRequest)(nil), "gnoi.optical.OTDRRequest")
	proto.RegisterType((*OTDRConfigurationProfile)(nil), "gnoi.optical.OTDRConfigurationProfile")
	proto.RegisterType((*OTDRConfiguration)(nil), "gnoi.optical.OTDRConfiguration")
	proto.RegisterType((*OTDRResponse)(nil), "gnoi.optical.OTDRResponse")
	proto.RegisterType((*OTDRTrace)(nil), "gnoi.optical.OTDRTrace")
	proto.RegisterType((*Event)(nil), "gnoi.optical.Event")
	proto.RegisterEnum("gnoi.optical.FiberTypeProfile", FiberTypeProfile_name, FiberTypeProfile_value)
	proto.RegisterEnum("gnoi.optical.OTDRRequest_OTDRResultsMethod", OTDRRequest_OTDRResultsMethod_name, OTDRRequest_OTDRResultsMethod_value)
	proto.RegisterEnum("gnoi.optical.OTDRResponse_OTDRState", OTDRResponse_OTDRState_name, OTDRResponse_OTDRState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Optical service

type OpticalClient interface {
	// InitiateOTDR triggers an optical time domain reflectometer (OTDR) trace to
	// be run on a specified port. The results of the trace may be sent back in
	// the response or saved on the device to be retrieved later. If the
	// information is saved on the device a path to the file must be returned
	// which can later be used by File.Get or File.TransferToRemote. The RPC
	// should initiate the OTDR trace and wait until the OTDR trace has completed
	// and the device has processed the results before returning. If the RPC is
	// cancelled while in operation, the running OTDR trace should stop. As only
	// one OTDR trace can take place concurrently, the RPC should error if a
	// trace is currently running.
	InitiateOTDR(ctx context.Context, in *OTDRRequest, opts ...grpc.CallOption) (Optical_InitiateOTDRClient, error)
}

type opticalClient struct {
	cc *grpc.ClientConn
}

func NewOpticalClient(cc *grpc.ClientConn) OpticalClient {
	return &opticalClient{cc}
}

func (c *opticalClient) InitiateOTDR(ctx context.Context, in *OTDRRequest, opts ...grpc.CallOption) (Optical_InitiateOTDRClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Optical_serviceDesc.Streams[0], c.cc, "/gnoi.optical.Optical/InitiateOTDR", opts...)
	if err != nil {
		return nil, err
	}
	x := &opticalInitiateOTDRClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Optical_InitiateOTDRClient interface {
	Recv() (*OTDRResponse, error)
	grpc.ClientStream
}

type opticalInitiateOTDRClient struct {
	grpc.ClientStream
}

func (x *opticalInitiateOTDRClient) Recv() (*OTDRResponse, error) {
	m := new(OTDRResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Optical service

type OpticalServer interface {
	// InitiateOTDR triggers an optical time domain reflectometer (OTDR) trace to
	// be run on a specified port. The results of the trace may be sent back in
	// the response or saved on the device to be retrieved later. If the
	// information is saved on the device a path to the file must be returned
	// which can later be used by File.Get or File.TransferToRemote. The RPC
	// should initiate the OTDR trace and wait until the OTDR trace has completed
	// and the device has processed the results before returning. If the RPC is
	// cancelled while in operation, the running OTDR trace should stop. As only
	// one OTDR trace can take place concurrently, the RPC should error if a
	// trace is currently running.
	InitiateOTDR(*OTDRRequest, Optical_InitiateOTDRServer) error
}

func RegisterOpticalServer(s *grpc.Server, srv OpticalServer) {
	s.RegisterService(&_Optical_serviceDesc, srv)
}

func _Optical_InitiateOTDR_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OTDRRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OpticalServer).InitiateOTDR(m, &opticalInitiateOTDRServer{stream})
}

type Optical_InitiateOTDRServer interface {
	Send(*OTDRResponse) error
	grpc.ServerStream
}

type opticalInitiateOTDRServer struct {
	grpc.ServerStream
}

func (x *opticalInitiateOTDRServer) Send(m *OTDRResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Optical_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gnoi.optical.Optical",
	HandlerType: (*OpticalServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "InitiateOTDR",
			Handler:       _Optical_InitiateOTDR_Handler,
			ServerStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("optical/optical.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 893 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x55, 0xdd, 0x6e, 0xe2, 0x46,
	0x14, 0x8e, 0x61, 0x81, 0x70, 0xf8, 0x89, 0x77, 0x68, 0x1a, 0x36, 0x52, 0x5b, 0xe4, 0x6e, 0x5b,
	0xd4, 0xac, 0x48, 0xca, 0x4a, 0xbd, 0x68, 0xd5, 0xaa, 0xd9, 0x60, 0x36, 0x28, 0x60, 0xd0, 0xd8,
	0x29, 0x37, 0x95, 0x46, 0xc6, 0x0c, 0x60, 0xd5, 0x78, 0xbc, 0xf6, 0x90, 0xd5, 0xee, 0x53, 0xf4,
	0xb2, 0x8f, 0xd2, 0xe7, 0x68, 0x1f, 0xa1, 0x52, 0x9f, 0xa3, 0x9a, 0x19, 0x3b, 0x40, 0xd3, 0xa8,
	0xea, 0x0d, 0xf8, 0x7c, 0xe7, 0x3b, 0x87, 0xef, 0x9c, 0xef, 0x00, 0x70, 0xcc, 0x22, 0xee, 0x7b,
	0x6e, 0x70, 0x9e, 0xbe, 0x77, 0xa2, 0x98, 0x71, 0x86, 0xaa, 0xcb, 0x90, 0xf9, 0x9d, 0x14, 0x3b,
	0x7d, 0xb1, 0xf4, 0xf9, 0x6a, 0x33, 0xeb, 0x78, 0x6c, 0x7d, 0xce, 0x22, 0x1a, 0x7a, 0x2c, 0x5c,
	0xf8, 0xcb, 0x73, 0xc1, 0x39, 0xe7, 0xef, 0x22, 0x9a, 0xa8, 0x57, 0x55, 0x6b, 0xfc, 0x91, 0x83,
	0xca, 0xd8, 0xe9, 0x61, 0x4c, 0xdf, 0x6c, 0x68, 0xc2, 0x51, 0x07, 0xca, 0x1e, 0x5b, 0x47, 0x2c,
	0xa4, 0x21, 0x6f, 0x6a, 0x2d, 0xad, 0x5d, 0xe9, 0xea, 0x1d, 0xd9, 0x5f, 0x55, 0x4d, 0x5c, 0xbe,
	0xc2, 0x5b, 0x0a, 0xc2, 0x50, 0x8f, 0x69, 0xb2, 0x09, 0x78, 0x42, 0xd6, 0x94, 0xaf, 0xd8, 0xbc,
	0x99, 0x6b, 0xe5, 0xdb, 0xf5, 0xee, 0x59, 0x67, 0x57, 0x54, 0x67, 0xe7, 0x23, 0xd2, 0x67, 0x59,
	0x33, 0x92, 0x25, 0xb8, 0x16, 0xef, 0x86, 0x68, 0x08, 0x35, 0x25, 0x7a, 0x13, 0xbb, 0xdc, 0x67,
	0x61, 0x33, 0x2f, 0x75, 0x7c, 0xfe, 0xb0, 0xe5, 0xd5, 0x2e, 0x6d, 0x12, 0xb3, 0x85, 0x1f, 0x50,
	0xbc, 0x5f, 0x8c, 0x3e, 0x80, 0x42, 0xe0, 0xce, 0x68, 0xd0, 0x7c, 0xd2, 0xd2, 0xda, 0x65, 0xac,
	0x02, 0xe3, 0x27, 0x78, 0xfa, 0x40, 0x07, 0x6a, 0xc0, 0x11, 0x36, 0xed, 0xdb, 0xa1, 0x63, 0x93,
	0x5b, 0xeb, 0xc6, 0x1a, 0x4f, 0x2d, 0xfd, 0x00, 0x3d, 0x83, 0xe3, 0x0c, 0x74, 0xc6, 0x64, 0x38,
	0xbe, 0xba, 0x1c, 0x92, 0xde, 0xc0, 0xbe, 0xd1, 0x35, 0x74, 0x02, 0x8d, 0x2c, 0x35, 0xb0, 0x08,
	0x36, 0xed, 0xc9, 0xd8, 0xb2, 0x4d, 0x3d, 0x67, 0xfc, 0xa2, 0x41, 0xf3, 0x31, 0x7d, 0xe8, 0x0b,
	0xa8, 0x7b, 0x9b, 0x84, 0xb3, 0x35, 0x89, 0x14, 0x22, 0xf7, 0x5c, 0xbe, 0x3e, 0xc0, 0x35, 0x85,
	0x67, 0xc4, 0x6f, 0xa1, 0x94, 0x31, 0x72, 0x72, 0x03, 0x9f, 0xfc, 0xc7, 0x06, 0xae, 0x0f, 0x70,
	0x56, 0xf1, 0xaa, 0x0e, 0xd5, 0xf4, 0x91, 0x08, 0xe7, 0x8c, 0xbf, 0x34, 0x35, 0xf1, 0x5e, 0x01,
	0x7a, 0x01, 0xc8, 0xf5, 0xde, 0x6c, 0xfc, 0xc4, 0x17, 0x21, 0xe1, 0xfe, 0x9a, 0x92, 0x44, 0xea,
	0xa9, 0x61, 0x7d, 0x27, 0xe3, 0xf8, 0x6b, 0x6a, 0xa3, 0xe7, 0x50, 0x8f, 0x36, 0x41, 0x42, 0xc9,
	0x5b, 0x7f, 0xce, 0x57, 0x24, 0x4c, 0xa4, 0xae, 0x1c, 0xae, 0x4a, 0x74, 0x2a, 0x40, 0x2b, 0x41,
	0x9f, 0x41, 0xfd, 0xad, 0x7b, 0x47, 0x03, 0x1a, 0x2e, 0xf9, 0x8a, 0xac, 0x57, 0xef, 0xa5, 0x7f,
	0x4f, 0x70, 0x6d, 0x8b, 0x8e, 0x56, 0xef, 0xd1, 0x09, 0x94, 0x62, 0x37, 0x5c, 0x52, 0xb2, 0x96,
	0xce, 0xe4, 0x70, 0x51, 0x86, 0x23, 0xf4, 0x1d, 0xc0, 0xc2, 0x9f, 0xd1, 0x58, 0xea, 0x6e, 0x16,
	0x5a, 0x5a, 0xbb, 0xde, 0xfd, 0x78, 0x7f, 0xf2, 0xbe, 0xc8, 0x3b, 0xef, 0x22, 0x9a, 0x79, 0x5e,
	0x5e, 0x64, 0x88, 0xf1, 0xa7, 0x06, 0xd5, 0xd4, 0xda, 0x88, 0x85, 0x09, 0x45, 0x1f, 0x01, 0x04,
	0xcc, 0x73, 0x03, 0x12, 0xb9, 0x7c, 0xa5, 0x76, 0x8d, 0xcb, 0x12, 0x11, 0xc7, 0x8c, 0xbe, 0x06,
	0x60, 0x7c, 0x1e, 0x13, 0x1e, 0xbb, 0x5e, 0xb6, 0xe8, 0x93, 0x87, 0x8b, 0x76, 0x44, 0x1a, 0x97,
	0x05, 0x55, 0x3e, 0xa2, 0x6f, 0xa0, 0x90, 0x70, 0x97, 0x53, 0x39, 0x5d, 0xbd, 0xfb, 0xfc, 0xdf,
	0x0e, 0x5e, 0x29, 0x90, 0x81, 0x2d, 0xb8, 0x58, 0x95, 0x18, 0x3f, 0x40, 0xf9, 0x1e, 0x43, 0x15,
	0x28, 0x6d, 0xaf, 0xad, 0x02, 0x25, 0x7c, 0x6b, 0x59, 0x03, 0xeb, 0xb5, 0xae, 0x89, 0x60, 0x62,
	0x5a, 0x3d, 0x11, 0xe4, 0x50, 0x15, 0x0e, 0xaf, 0xc6, 0xa3, 0xc9, 0xd0, 0x74, 0x4c, 0x3d, 0x6f,
	0xfc, 0x96, 0x53, 0x2d, 0x94, 0x16, 0x03, 0x6a, 0x9c, 0x71, 0x37, 0x20, 0x01, 0x4b, 0x12, 0x32,
	0x9f, 0xc9, 0x29, 0x73, 0xb8, 0x22, 0xc1, 0x21, 0x4b, 0x92, 0xde, 0x4c, 0x98, 0x97, 0x72, 0x52,
	0x63, 0x32, 0xf3, 0x14, 0x49, 0xf9, 0x82, 0x5e, 0xc2, 0x87, 0xe9, 0x08, 0x24, 0xa6, 0x7c, 0x13,
	0x87, 0xf7, 0x2d, 0xf3, 0x92, 0xdd, 0x48, 0xb3, 0x58, 0x26, 0xd3, 0xd6, 0x67, 0x80, 0xdc, 0x3b,
	0x1a, 0xbb, 0x4b, 0x9a, 0xb1, 0xc9, 0xcf, 0x99, 0xab, 0x47, 0x69, 0x46, 0x51, 0x6f, 0xd6, 0x08,
	0xc3, 0xf1, 0xdc, 0x4f, 0x3c, 0x76, 0x47, 0x63, 0x3a, 0x27, 0xff, 0xdb, 0xe9, 0xc6, 0xb6, 0xf8,
	0x3e, 0x87, 0xce, 0xa0, 0x48, 0xef, 0x68, 0xc8, 0x93, 0x66, 0xb1, 0x95, 0x6f, 0x57, 0xba, 0x8d,
	0xfd, 0x26, 0xa6, 0xc8, 0xe1, 0x94, 0x62, 0xcc, 0xa1, 0x20, 0x01, 0x71, 0x18, 0x73, 0x3f, 0xe1,
	0x6e, 0xe8, 0x89, 0x23, 0x54, 0x2b, 0x2b, 0x67, 0xc8, 0x48, 0x1c, 0x68, 0x36, 0xbb, 0xda, 0x54,
	0x31, 0x50, 0xe3, 0x7e, 0x0a, 0xb5, 0x98, 0x2e, 0x02, 0xea, 0xc9, 0xef, 0xcc, 0xfd, 0x6a, 0xaa,
	0x5b, 0xb0, 0x37, 0xfb, 0xf2, 0x57, 0x0d, 0xf4, 0x7f, 0x8a, 0x47, 0x47, 0x50, 0xe9, 0x3b, 0x13,
	0xb2, 0x67, 0xb7, 0x00, 0x7a, 0x76, 0x5f, 0xd7, 0x84, 0xc3, 0x22, 0x18, 0x9a, 0x97, 0x7d, 0xe5,
	0xb7, 0x88, 0x6c, 0x7b, 0xd4, 0xd7, 0xf3, 0x19, 0xd1, 0x99, 0x5e, 0xe9, 0x4f, 0xb2, 0x94, 0x33,
	0xc5, 0xb6, 0x5e, 0x40, 0x00, 0x45, 0x59, 0x66, 0xeb, 0x45, 0xa4, 0x43, 0x55, 0x66, 0x4c, 0x7c,
	0x39, 0xbd, 0xfc, 0xd1, 0xd4, 0x4b, 0xe8, 0x29, 0xd4, 0x32, 0x64, 0x38, 0x78, 0x7d, 0xed, 0xe8,
	0x87, 0x5d, 0x07, 0x4a, 0x63, 0xb5, 0x19, 0x34, 0x80, 0xea, 0x20, 0xf4, 0xb9, 0xef, 0x72, 0x2a,
	0xae, 0x09, 0x3d, 0x7b, 0xf4, 0x67, 0xfb, 0xf4, 0xf4, 0xf1, 0x03, 0x37, 0x0e, 0x2e, 0xb4, 0x57,
	0x87, 0xbf, 0x7f, 0x5f, 0xb8, 0xe8, 0x7c, 0xd5, 0xb9, 0x98, 0x15, 0xe5, 0x5f, 0xcb, 0xcb, 0xbf,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x02, 0xcb, 0x72, 0x49, 0xaf, 0x06, 0x00, 0x00,
}
