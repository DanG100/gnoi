// Code generated by protoc-gen-go.
// source: otdr/otdr.proto
// DO NOT EDIT!

/*
Package gnoi_optical is a generated protocol buffer package.

It is generated from these files:
	otdr/otdr.proto

It has these top-level messages:
	InitiateRequest
	OTDRConfigurationProfile
	OTDRConfiguration
	InitiateProgress
	InitiateResults
	InitiateError
	InitiateResponse
	OTDRTrace
	Event
*/
package gnoi_optical

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import gnoi_types "github.com/openconfig/gnoi/types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Type definition for different profiles of fiber types. These match what is
// already defined in OpenConfig under the FIBER_TYPE_PROFILE identityref in
// openconfig-optical-amplifier.yang model.
type FiberTypeProfile int32

const (
	FiberTypeProfile_FTP_UNKNOWN   FiberTypeProfile = 0
	FiberTypeProfile_FTP_DSF       FiberTypeProfile = 1
	FiberTypeProfile_FTP_LEAF      FiberTypeProfile = 2
	FiberTypeProfile_FTP_SSMF      FiberTypeProfile = 3
	FiberTypeProfile_FTP_TWC       FiberTypeProfile = 4
	FiberTypeProfile_FTP_TWRS      FiberTypeProfile = 5
	FiberTypeProfile_FTP_LS        FiberTypeProfile = 6
	FiberTypeProfile_FTP_TERAWAVE  FiberTypeProfile = 7
	FiberTypeProfile_FTP_TERALIGHT FiberTypeProfile = 8
)

var FiberTypeProfile_name = map[int32]string{
	0: "FTP_UNKNOWN",
	1: "FTP_DSF",
	2: "FTP_LEAF",
	3: "FTP_SSMF",
	4: "FTP_TWC",
	5: "FTP_TWRS",
	6: "FTP_LS",
	7: "FTP_TERAWAVE",
	8: "FTP_TERALIGHT",
}
var FiberTypeProfile_value = map[string]int32{
	"FTP_UNKNOWN":   0,
	"FTP_DSF":       1,
	"FTP_LEAF":      2,
	"FTP_SSMF":      3,
	"FTP_TWC":       4,
	"FTP_TWRS":      5,
	"FTP_LS":        6,
	"FTP_TERAWAVE":  7,
	"FTP_TERALIGHT": 8,
}

func (x FiberTypeProfile) String() string {
	return proto.EnumName(FiberTypeProfile_name, int32(x))
}
func (FiberTypeProfile) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type InitiateRequest_ResultsMethod int32

const (
	InitiateRequest_RESULTS_UNKNOWN       InitiateRequest_ResultsMethod = 0
	InitiateRequest_RESULTS_TO_LOCAL_DISK InitiateRequest_ResultsMethod = 1
	InitiateRequest_RESULTS_IN_RESPONSE   InitiateRequest_ResultsMethod = 2
)

var InitiateRequest_ResultsMethod_name = map[int32]string{
	0: "RESULTS_UNKNOWN",
	1: "RESULTS_TO_LOCAL_DISK",
	2: "RESULTS_IN_RESPONSE",
}
var InitiateRequest_ResultsMethod_value = map[string]int32{
	"RESULTS_UNKNOWN":       0,
	"RESULTS_TO_LOCAL_DISK": 1,
	"RESULTS_IN_RESPONSE":   2,
}

func (x InitiateRequest_ResultsMethod) String() string {
	return proto.EnumName(InitiateRequest_ResultsMethod_name, int32(x))
}
func (InitiateRequest_ResultsMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0}
}

// The State enum defines possible states that the OTDR trace may be in
// while running the operation.
type InitiateProgress_State int32

const (
	InitiateProgress_UNKNOWN  InitiateProgress_State = 0
	InitiateProgress_RUNNING  InitiateProgress_State = 1
	InitiateProgress_PENDING  InitiateProgress_State = 2
	InitiateProgress_COMPLETE InitiateProgress_State = 3
)

var InitiateProgress_State_name = map[int32]string{
	0: "UNKNOWN",
	1: "RUNNING",
	2: "PENDING",
	3: "COMPLETE",
}
var InitiateProgress_State_value = map[string]int32{
	"UNKNOWN":  0,
	"RUNNING":  1,
	"PENDING":  2,
	"COMPLETE": 3,
}

func (x InitiateProgress_State) String() string {
	return proto.EnumName(InitiateProgress_State_name, int32(x))
}
func (InitiateProgress_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type InitiateError_Type int32

const (
	// An unspecified error. Must use the detail value to describe the issue.
	InitiateError_UNSPECIFIED InitiateError_Type = 0
	// An existing OTDR trace is already in progress.
	InitiateError_ALREADY_IN_PROGRESS InitiateError_Type = 1
	// The OTDR hardware has failed and cannot complete an OTDR trace.
	InitiateError_HARDWARE_FAILURE InitiateError_Type = 2
)

var InitiateError_Type_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "ALREADY_IN_PROGRESS",
	2: "HARDWARE_FAILURE",
}
var InitiateError_Type_value = map[string]int32{
	"UNSPECIFIED":         0,
	"ALREADY_IN_PROGRESS": 1,
	"HARDWARE_FAILURE":    2,
}

func (x InitiateError_Type) String() string {
	return proto.EnumName(InitiateError_Type_name, int32(x))
}
func (InitiateError_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type InitiateRequest struct {
	// Absolute path to the /components/component list member in the OpenConfig
	// model corresponding to the port to perform the OTDR trace from.
	// (e.g., /components/component[name=otdr-1-1])
	Component *gnoi_types.Path `protobuf:"bytes,1,opt,name=component" json:"component,omitempty"`
	// Describes how the results of the OTDR trace should be made available. More
	// than one option may be specified if desired.
	ResultsMethod []InitiateRequest_ResultsMethod `protobuf:"varint,2,rep,packed,name=results_method,json=resultsMethod,enum=gnoi.optical.InitiateRequest_ResultsMethod" json:"results_method,omitempty"`
	// Describes the configuration used to perform an OTDR trace for the needed
	// circumstance.
	Configuration *OTDRConfigurationProfile `protobuf:"bytes,3,opt,name=configuration" json:"configuration,omitempty"`
	// If specified, the device will label the OTDR trace so it can be recalled
	// later. For example, the initial OTDR trace measured during span
	// commissioning might be labeled "baseline".
	Label string `protobuf:"bytes,4,opt,name=label" json:"label,omitempty"`
}

func (m *InitiateRequest) Reset()                    { *m = InitiateRequest{} }
func (m *InitiateRequest) String() string            { return proto.CompactTextString(m) }
func (*InitiateRequest) ProtoMessage()               {}
func (*InitiateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *InitiateRequest) GetComponent() *gnoi_types.Path {
	if m != nil {
		return m.Component
	}
	return nil
}

func (m *InitiateRequest) GetConfiguration() *OTDRConfigurationProfile {
	if m != nil {
		return m.Configuration
	}
	return nil
}

type OTDRConfigurationProfile struct {
	// Types that are valid to be assigned to ProfileType:
	//	*OTDRConfigurationProfile_CustomProfile
	//	*OTDRConfigurationProfile_Profile
	ProfileType isOTDRConfigurationProfile_ProfileType `protobuf_oneof:"profile_type"`
}

func (m *OTDRConfigurationProfile) Reset()                    { *m = OTDRConfigurationProfile{} }
func (m *OTDRConfigurationProfile) String() string            { return proto.CompactTextString(m) }
func (*OTDRConfigurationProfile) ProtoMessage()               {}
func (*OTDRConfigurationProfile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isOTDRConfigurationProfile_ProfileType interface {
	isOTDRConfigurationProfile_ProfileType()
}

type OTDRConfigurationProfile_CustomProfile struct {
	CustomProfile string `protobuf:"bytes,1,opt,name=custom_profile,json=customProfile,oneof"`
}
type OTDRConfigurationProfile_Profile struct {
	Profile *OTDRConfiguration `protobuf:"bytes,2,opt,name=profile,oneof"`
}

func (*OTDRConfigurationProfile_CustomProfile) isOTDRConfigurationProfile_ProfileType() {}
func (*OTDRConfigurationProfile_Profile) isOTDRConfigurationProfile_ProfileType()       {}

func (m *OTDRConfigurationProfile) GetProfileType() isOTDRConfigurationProfile_ProfileType {
	if m != nil {
		return m.ProfileType
	}
	return nil
}

func (m *OTDRConfigurationProfile) GetCustomProfile() string {
	if x, ok := m.GetProfileType().(*OTDRConfigurationProfile_CustomProfile); ok {
		return x.CustomProfile
	}
	return ""
}

func (m *OTDRConfigurationProfile) GetProfile() *OTDRConfiguration {
	if x, ok := m.GetProfileType().(*OTDRConfigurationProfile_Profile); ok {
		return x.Profile
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OTDRConfigurationProfile) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OTDRConfigurationProfile_OneofMarshaler, _OTDRConfigurationProfile_OneofUnmarshaler, _OTDRConfigurationProfile_OneofSizer, []interface{}{
		(*OTDRConfigurationProfile_CustomProfile)(nil),
		(*OTDRConfigurationProfile_Profile)(nil),
	}
}

func _OTDRConfigurationProfile_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OTDRConfigurationProfile)
	// profile_type
	switch x := m.ProfileType.(type) {
	case *OTDRConfigurationProfile_CustomProfile:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.CustomProfile)
	case *OTDRConfigurationProfile_Profile:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Profile); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("OTDRConfigurationProfile.ProfileType has unexpected type %T", x)
	}
	return nil
}

func _OTDRConfigurationProfile_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OTDRConfigurationProfile)
	switch tag {
	case 1: // profile_type.custom_profile
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ProfileType = &OTDRConfigurationProfile_CustomProfile{x}
		return true, err
	case 2: // profile_type.profile
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OTDRConfiguration)
		err := b.DecodeMessage(msg)
		m.ProfileType = &OTDRConfigurationProfile_Profile{msg}
		return true, err
	default:
		return false, nil
	}
}

func _OTDRConfigurationProfile_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OTDRConfigurationProfile)
	// profile_type
	switch x := m.ProfileType.(type) {
	case *OTDRConfigurationProfile_CustomProfile:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.CustomProfile)))
		n += len(x.CustomProfile)
	case *OTDRConfigurationProfile_Profile:
		s := proto.Size(x.Profile)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// OTDR configuration options which can be set on the device. It is not required
// that every field be set as some fields may not apply for a given
// implementation.
type OTDRConfiguration struct {
	// The time in seconds in which the OTDR trace will run continuously to
	// collect data.
	AcquisitionTimeS uint32 `protobuf:"varint,1,opt,name=acquisition_time_s,json=acquisitionTimeS" json:"acquisition_time_s,omitempty"`
	// The pulse width in nanoseconds which defines how long pulses sent by the
	// OTDR will be during the test.
	PulseWidthNs float32 `protobuf:"fixed32,2,opt,name=pulse_width_ns,json=pulseWidthNs" json:"pulse_width_ns,omitempty"`
	// The wavelength in MHz that will be sent by the OTDR. This may be left blank
	// if the OTDR only supports one wavelength.
	WavelengthMhz uint64 `protobuf:"varint,3,opt,name=wavelength_mhz,json=wavelengthMhz" json:"wavelength_mhz,omitempty"`
	// The maximum fiber distance range in meters that the OTDR trace will
	// support.
	RangeM float32 `protobuf:"fixed32,4,opt,name=range_m,json=rangeM" json:"range_m,omitempty"`
	// The type of fiber that is being measured.
	FiberType FiberTypeProfile `protobuf:"varint,5,opt,name=fiber_type,json=fiberType,enum=gnoi.optical.FiberTypeProfile" json:"fiber_type,omitempty"`
}

func (m *OTDRConfiguration) Reset()                    { *m = OTDRConfiguration{} }
func (m *OTDRConfiguration) String() string            { return proto.CompactTextString(m) }
func (*OTDRConfiguration) ProtoMessage()               {}
func (*OTDRConfiguration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type InitiateProgress struct {
	// The state of the OTDR trace requested. Note that this does not include
	// error states as these should be returned as a gRPC error.
	State InitiateProgress_State `protobuf:"varint,1,opt,name=state,enum=gnoi.optical.InitiateProgress_State" json:"state,omitempty"`
}

func (m *InitiateProgress) Reset()                    { *m = InitiateProgress{} }
func (m *InitiateProgress) String() string            { return proto.CompactTextString(m) }
func (*InitiateProgress) ProtoMessage()               {}
func (*InitiateProgress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type InitiateResults struct {
	// The local path in which the OTDR file is saved on the device.
	LocalPath string `protobuf:"bytes,1,opt,name=local_path,json=localPath" json:"local_path,omitempty"`
	// The OTDR trace details in a structured format.
	OtdrTrace *OTDRTrace `protobuf:"bytes,2,opt,name=otdr_trace,json=otdrTrace" json:"otdr_trace,omitempty"`
}

func (m *InitiateResults) Reset()                    { *m = InitiateResults{} }
func (m *InitiateResults) String() string            { return proto.CompactTextString(m) }
func (*InitiateResults) ProtoMessage()               {}
func (*InitiateResults) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *InitiateResults) GetOtdrTrace() *OTDRTrace {
	if m != nil {
		return m.OtdrTrace
	}
	return nil
}

type InitiateError struct {
	Type   InitiateError_Type `protobuf:"varint,1,opt,name=type,enum=gnoi.optical.InitiateError_Type" json:"type,omitempty"`
	Detail string             `protobuf:"bytes,2,opt,name=detail" json:"detail,omitempty"`
}

func (m *InitiateError) Reset()                    { *m = InitiateError{} }
func (m *InitiateError) String() string            { return proto.CompactTextString(m) }
func (*InitiateError) ProtoMessage()               {}
func (*InitiateError) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// IntitiateResponse describes the possible response messages that will be
// streamed after the RPC is initiated. While the OTDR is running, "progress"
// messages should be sent at a regular interval. When the OTDR trace is
// completed, a final "results" or "error" message should be streamed before
// the RPC is terminated.
type InitiateResponse struct {
	// Types that are valid to be assigned to Response:
	//	*InitiateResponse_Progress
	//	*InitiateResponse_Results
	//	*InitiateResponse_Error
	Response isInitiateResponse_Response `protobuf_oneof:"response"`
}

func (m *InitiateResponse) Reset()                    { *m = InitiateResponse{} }
func (m *InitiateResponse) String() string            { return proto.CompactTextString(m) }
func (*InitiateResponse) ProtoMessage()               {}
func (*InitiateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isInitiateResponse_Response interface {
	isInitiateResponse_Response()
}

type InitiateResponse_Progress struct {
	Progress *InitiateProgress `protobuf:"bytes,1,opt,name=progress,oneof"`
}
type InitiateResponse_Results struct {
	Results *InitiateResults `protobuf:"bytes,2,opt,name=results,oneof"`
}
type InitiateResponse_Error struct {
	Error *InitiateError `protobuf:"bytes,3,opt,name=error,oneof"`
}

func (*InitiateResponse_Progress) isInitiateResponse_Response() {}
func (*InitiateResponse_Results) isInitiateResponse_Response()  {}
func (*InitiateResponse_Error) isInitiateResponse_Response()    {}

func (m *InitiateResponse) GetResponse() isInitiateResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *InitiateResponse) GetProgress() *InitiateProgress {
	if x, ok := m.GetResponse().(*InitiateResponse_Progress); ok {
		return x.Progress
	}
	return nil
}

func (m *InitiateResponse) GetResults() *InitiateResults {
	if x, ok := m.GetResponse().(*InitiateResponse_Results); ok {
		return x.Results
	}
	return nil
}

func (m *InitiateResponse) GetError() *InitiateError {
	if x, ok := m.GetResponse().(*InitiateResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InitiateResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InitiateResponse_OneofMarshaler, _InitiateResponse_OneofUnmarshaler, _InitiateResponse_OneofSizer, []interface{}{
		(*InitiateResponse_Progress)(nil),
		(*InitiateResponse_Results)(nil),
		(*InitiateResponse_Error)(nil),
	}
}

func _InitiateResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InitiateResponse)
	// response
	switch x := m.Response.(type) {
	case *InitiateResponse_Progress:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Progress); err != nil {
			return err
		}
	case *InitiateResponse_Results:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Results); err != nil {
			return err
		}
	case *InitiateResponse_Error:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InitiateResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _InitiateResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InitiateResponse)
	switch tag {
	case 1: // response.progress
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InitiateProgress)
		err := b.DecodeMessage(msg)
		m.Response = &InitiateResponse_Progress{msg}
		return true, err
	case 2: // response.results
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InitiateResults)
		err := b.DecodeMessage(msg)
		m.Response = &InitiateResponse_Results{msg}
		return true, err
	case 3: // response.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InitiateError)
		err := b.DecodeMessage(msg)
		m.Response = &InitiateResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InitiateResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InitiateResponse)
	// response
	switch x := m.Response.(type) {
	case *InitiateResponse_Progress:
		s := proto.Size(x.Progress)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InitiateResponse_Results:
		s := proto.Size(x.Results)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InitiateResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OTDRTrace struct {
	// Total measured loss of the fiber.
	TotalLossDb float32 `protobuf:"fixed32,1,opt,name=total_loss_db,json=totalLossDb" json:"total_loss_db,omitempty"`
	// Total measured length of the fiber in meters.
	TotalLengthM float32 `protobuf:"fixed32,2,opt,name=total_length_m,json=totalLengthM" json:"total_length_m,omitempty"`
	// Optical return loss of the fiber in dB.
	OpticalReturnLossDb float32 `protobuf:"fixed32,3,opt,name=optical_return_loss_db,json=opticalReturnLossDb" json:"optical_return_loss_db,omitempty"`
	// Average fiber loss (dB/km)
	AverageLossDbKm float32 `protobuf:"fixed32,4,opt,name=average_loss_db_km,json=averageLossDbKm" json:"average_loss_db_km,omitempty"`
	// Discovered fiber type, if the OTDR can infer this information.
	DiscoveredFiberType FiberTypeProfile `protobuf:"varint,5,opt,name=discovered_fiber_type,json=discoveredFiberType,enum=gnoi.optical.FiberTypeProfile" json:"discovered_fiber_type,omitempty"`
	Events              []*Event         `protobuf:"bytes,6,rep,name=events" json:"events,omitempty"`
}

func (m *OTDRTrace) Reset()                    { *m = OTDRTrace{} }
func (m *OTDRTrace) String() string            { return proto.CompactTextString(m) }
func (*OTDRTrace) ProtoMessage()               {}
func (*OTDRTrace) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *OTDRTrace) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

type Event struct {
	// Distance at which the event occurred in meters.
	DistanceM float32 `protobuf:"fixed32,1,opt,name=distance_m,json=distanceM" json:"distance_m,omitempty"`
	// The fiber loss that occurred at the event in dB.
	LossDb float32 `protobuf:"fixed32,2,opt,name=loss_db,json=lossDb" json:"loss_db,omitempty"`
	// The reflection that occurred at the event in dB.
	ReflectionDb float32 `protobuf:"fixed32,3,opt,name=reflection_db,json=reflectionDb" json:"reflection_db,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func init() {
	proto.RegisterType((*InitiateRequest)(nil), "gnoi.optical.InitiateRequest")
	proto.RegisterType((*OTDRConfigurationProfile)(nil), "gnoi.optical.OTDRConfigurationProfile")
	proto.RegisterType((*OTDRConfiguration)(nil), "gnoi.optical.OTDRConfiguration")
	proto.RegisterType((*InitiateProgress)(nil), "gnoi.optical.InitiateProgress")
	proto.RegisterType((*InitiateResults)(nil), "gnoi.optical.InitiateResults")
	proto.RegisterType((*InitiateError)(nil), "gnoi.optical.InitiateError")
	proto.RegisterType((*InitiateResponse)(nil), "gnoi.optical.InitiateResponse")
	proto.RegisterType((*OTDRTrace)(nil), "gnoi.optical.OTDRTrace")
	proto.RegisterType((*Event)(nil), "gnoi.optical.Event")
	proto.RegisterEnum("gnoi.optical.FiberTypeProfile", FiberTypeProfile_name, FiberTypeProfile_value)
	proto.RegisterEnum("gnoi.optical.InitiateRequest_ResultsMethod", InitiateRequest_ResultsMethod_name, InitiateRequest_ResultsMethod_value)
	proto.RegisterEnum("gnoi.optical.InitiateProgress_State", InitiateProgress_State_name, InitiateProgress_State_value)
	proto.RegisterEnum("gnoi.optical.InitiateError_Type", InitiateError_Type_name, InitiateError_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for OTDR service

type OTDRClient interface {
	// Initiate triggers an optical time domain reflectometer (OTDR) trace to
	// be run on a specified port. The results of the trace may be sent back in
	// the response or saved on the device to be retrieved later. If the
	// information is saved on the device a path to the file must be returned
	// which can later be used by File.Get or File.TransferToRemote. The RPC
	// should initiate the OTDR trace and wait until the OTDR trace has completed
	// and the device has processed the results before returning. If the RPC is
	// cancelled while in operation, the running OTDR trace should stop.
	Initiate(ctx context.Context, in *InitiateRequest, opts ...grpc.CallOption) (OTDR_InitiateClient, error)
}

type oTDRClient struct {
	cc *grpc.ClientConn
}

func NewOTDRClient(cc *grpc.ClientConn) OTDRClient {
	return &oTDRClient{cc}
}

func (c *oTDRClient) Initiate(ctx context.Context, in *InitiateRequest, opts ...grpc.CallOption) (OTDR_InitiateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OTDR_serviceDesc.Streams[0], c.cc, "/gnoi.optical.OTDR/Initiate", opts...)
	if err != nil {
		return nil, err
	}
	x := &oTDRInitiateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OTDR_InitiateClient interface {
	Recv() (*InitiateResponse, error)
	grpc.ClientStream
}

type oTDRInitiateClient struct {
	grpc.ClientStream
}

func (x *oTDRInitiateClient) Recv() (*InitiateResponse, error) {
	m := new(InitiateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for OTDR service

type OTDRServer interface {
	// Initiate triggers an optical time domain reflectometer (OTDR) trace to
	// be run on a specified port. The results of the trace may be sent back in
	// the response or saved on the device to be retrieved later. If the
	// information is saved on the device a path to the file must be returned
	// which can later be used by File.Get or File.TransferToRemote. The RPC
	// should initiate the OTDR trace and wait until the OTDR trace has completed
	// and the device has processed the results before returning. If the RPC is
	// cancelled while in operation, the running OTDR trace should stop.
	Initiate(*InitiateRequest, OTDR_InitiateServer) error
}

func RegisterOTDRServer(s *grpc.Server, srv OTDRServer) {
	s.RegisterService(&_OTDR_serviceDesc, srv)
}

func _OTDR_Initiate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InitiateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OTDRServer).Initiate(m, &oTDRInitiateServer{stream})
}

type OTDR_InitiateServer interface {
	Send(*InitiateResponse) error
	grpc.ServerStream
}

type oTDRInitiateServer struct {
	grpc.ServerStream
}

func (x *oTDRInitiateServer) Send(m *InitiateResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _OTDR_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gnoi.optical.OTDR",
	HandlerType: (*OTDRServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Initiate",
			Handler:       _OTDR_Initiate_Handler,
			ServerStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("otdr/otdr.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1065 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x55, 0xdb, 0x6e, 0x1b, 0x45,
	0x18, 0xf6, 0xfa, 0xec, 0xdf, 0x87, 0x6c, 0x27, 0x3d, 0x98, 0xa2, 0x16, 0x6b, 0x29, 0x10, 0x91,
	0x6a, 0x13, 0x1c, 0x84, 0x04, 0x14, 0x24, 0x27, 0x5e, 0xc7, 0x56, 0x7c, 0xd2, 0xac, 0x8d, 0xe1,
	0x6a, 0xb4, 0xb6, 0x27, 0xf6, 0x8a, 0xf5, 0x8e, 0xbb, 0x33, 0x4e, 0xd5, 0x3e, 0x03, 0x17, 0x5c,
	0xf2, 0x02, 0xbc, 0x03, 0x0f, 0xc1, 0x15, 0xbc, 0x03, 0xcf, 0x81, 0x66, 0x76, 0x37, 0xb1, 0xdb,
	0x26, 0x88, 0x1b, 0xcb, 0xff, 0xf7, 0x7f, 0xff, 0xcc, 0x7f, 0xfa, 0x66, 0x61, 0x8f, 0x89, 0x79,
	0x70, 0x24, 0x7f, 0xcc, 0x75, 0xc0, 0x04, 0x43, 0xa5, 0x85, 0xcf, 0x5c, 0x93, 0xad, 0x85, 0x3b,
	0x73, 0xbc, 0xc7, 0xcf, 0x17, 0xae, 0x58, 0x6e, 0xa6, 0xe6, 0x8c, 0xad, 0x8e, 0xd8, 0x9a, 0xfa,
	0x33, 0xe6, 0x5f, 0xba, 0x8b, 0x23, 0xc9, 0x39, 0x12, 0xaf, 0xd7, 0x94, 0x87, 0xbf, 0x61, 0xac,
	0xf1, 0x77, 0x12, 0xf6, 0x3a, 0xbe, 0x2b, 0x5c, 0x47, 0x50, 0x4c, 0x5f, 0x6e, 0x28, 0x17, 0xc8,
	0x84, 0xc2, 0x8c, 0xad, 0xd6, 0xcc, 0xa7, 0xbe, 0xa8, 0x6a, 0x35, 0xed, 0xa0, 0x58, 0xd7, 0x4d,
	0x75, 0x47, 0x18, 0x39, 0x74, 0xc4, 0x12, 0xdf, 0x50, 0x10, 0x86, 0x4a, 0x40, 0xf9, 0xc6, 0x13,
	0x9c, 0xac, 0xa8, 0x58, 0xb2, 0x79, 0x35, 0x59, 0x4b, 0x1d, 0x54, 0xea, 0x87, 0xe6, 0x76, 0x62,
	0xe6, 0x5b, 0xd7, 0x98, 0x38, 0x8c, 0xe9, 0xa9, 0x10, 0x5c, 0x0e, 0xb6, 0x4d, 0xd4, 0x85, 0x72,
	0x98, 0xf8, 0x26, 0x70, 0x84, 0xcb, 0xfc, 0x6a, 0x4a, 0xe5, 0xf1, 0xe9, 0xee, 0x91, 0x83, 0x51,
	0x13, 0x9f, 0x6d, 0xd3, 0x86, 0x01, 0xbb, 0x74, 0x3d, 0x8a, 0x77, 0x83, 0xd1, 0x7d, 0xc8, 0x78,
	0xce, 0x94, 0x7a, 0xd5, 0x74, 0x4d, 0x3b, 0x28, 0xe0, 0xd0, 0x30, 0x7e, 0x84, 0xf2, 0x4e, 0x0e,
	0x68, 0x1f, 0xf6, 0xb0, 0x65, 0x8f, 0xbb, 0x23, 0x9b, 0x8c, 0xfb, 0x17, 0xfd, 0xc1, 0xa4, 0xaf,
	0x27, 0xd0, 0x07, 0xf0, 0x20, 0x06, 0x47, 0x03, 0xd2, 0x1d, 0x9c, 0x35, 0xba, 0xa4, 0xd9, 0xb1,
	0x2f, 0x74, 0x0d, 0x3d, 0x82, 0xfd, 0xd8, 0xd5, 0xe9, 0x13, 0x6c, 0xd9, 0xc3, 0x41, 0xdf, 0xb6,
	0xf4, 0xa4, 0xf1, 0xab, 0x06, 0xd5, 0xdb, 0x72, 0x43, 0x9f, 0x41, 0x65, 0xb6, 0xe1, 0x82, 0xad,
	0xc8, 0x3a, 0x44, 0x54, 0x8f, 0x0b, 0xed, 0x04, 0x2e, 0x87, 0x78, 0x4c, 0xfc, 0x16, 0x72, 0x31,
	0x23, 0xa9, 0xaa, 0xff, 0xe8, 0x3f, 0xaa, 0x6f, 0x27, 0x70, 0x1c, 0x71, 0x5a, 0x81, 0x52, 0xf4,
	0x97, 0xc8, 0xa9, 0x19, 0xff, 0x68, 0x70, 0xef, 0x9d, 0x00, 0xf4, 0x1c, 0x90, 0x33, 0x7b, 0xb9,
	0x71, 0xb9, 0x2b, 0x4d, 0x22, 0xdc, 0x15, 0x25, 0x5c, 0xe5, 0x53, 0xc6, 0xfa, 0x96, 0x67, 0xe4,
	0xae, 0xa8, 0x8d, 0x9e, 0x41, 0x65, 0xbd, 0xf1, 0x38, 0x25, 0xaf, 0xdc, 0xb9, 0x58, 0x12, 0x9f,
	0xab, 0xbc, 0x92, 0xb8, 0xa4, 0xd0, 0x89, 0x04, 0xfb, 0x1c, 0x7d, 0x02, 0x95, 0x57, 0xce, 0x15,
	0xf5, 0xa8, 0xbf, 0x10, 0x4b, 0xb2, 0x5a, 0xbe, 0x51, 0xb3, 0x4b, 0xe3, 0xf2, 0x0d, 0xda, 0x5b,
	0xbe, 0x41, 0x8f, 0x20, 0x17, 0x38, 0xfe, 0x82, 0x92, 0x95, 0x9a, 0x4a, 0x12, 0x67, 0x95, 0xd9,
	0x43, 0xdf, 0x01, 0x5c, 0xba, 0x53, 0x1a, 0xa8, 0xbc, 0xab, 0x99, 0x9a, 0x76, 0x50, 0xa9, 0x3f,
	0xdd, 0xad, 0xbc, 0x25, 0xfd, 0xa3, 0xd7, 0x6b, 0x1a, 0xcf, 0xbb, 0x70, 0x19, 0x23, 0xc6, 0x2f,
	0x1a, 0xe8, 0xf1, 0xaa, 0x0d, 0x03, 0xb6, 0x08, 0x28, 0xe7, 0xe8, 0x1b, 0xc8, 0x70, 0xe1, 0x88,
	0xb0, 0xd5, 0x95, 0xfa, 0xb3, 0xf7, 0x6f, 0x66, 0x4c, 0x37, 0x6d, 0xc9, 0xc5, 0x61, 0x88, 0xf1,
	0x02, 0x32, 0xca, 0x46, 0x45, 0xc8, 0xdd, 0xac, 0x45, 0x11, 0x72, 0x78, 0xdc, 0xef, 0x77, 0xfa,
	0xe7, 0xba, 0x26, 0x8d, 0xa1, 0xd5, 0x6f, 0x4a, 0x23, 0x89, 0x4a, 0x90, 0x3f, 0x1b, 0xf4, 0x86,
	0x5d, 0x6b, 0x64, 0xe9, 0x29, 0x63, 0xb9, 0xad, 0x2f, 0xb5, 0x6c, 0xe8, 0x09, 0x80, 0xc7, 0x66,
	0x8e, 0x47, 0xd6, 0x8e, 0x58, 0x86, 0xc3, 0xc7, 0x05, 0x85, 0x48, 0x65, 0xa1, 0xaf, 0x00, 0xa4,
	0xb8, 0x89, 0x08, 0x9c, 0x59, 0x3c, 0xf9, 0x47, 0xef, 0x4e, 0x7e, 0x24, 0xdd, 0xb8, 0x20, 0xa9,
	0xea, 0xaf, 0xf1, 0xbb, 0x06, 0xe5, 0xf8, 0x2a, 0x2b, 0x08, 0x58, 0x80, 0xbe, 0x84, 0xb4, 0xea,
	0x61, 0x58, 0x74, 0xed, 0xfd, 0x45, 0x2b, 0xaa, 0x29, 0x5b, 0x87, 0x15, 0x1b, 0x3d, 0x84, 0xec,
	0x9c, 0x0a, 0xc7, 0xf5, 0xd4, 0xdd, 0x05, 0x1c, 0x59, 0x46, 0x0b, 0xd2, 0x92, 0x85, 0xf6, 0xa0,
	0x38, 0xee, 0xdb, 0x43, 0xeb, 0xac, 0xd3, 0xea, 0x58, 0x4d, 0x3d, 0x21, 0x65, 0xd0, 0xe8, 0x62,
	0xab, 0xd1, 0xfc, 0x49, 0xca, 0x60, 0x88, 0x07, 0xe7, 0xd8, 0xb2, 0x6d, 0x5d, 0x43, 0xf7, 0x41,
	0x6f, 0x37, 0x70, 0x73, 0xd2, 0xc0, 0x16, 0x69, 0x35, 0x3a, 0xdd, 0x31, 0x96, 0xe2, 0xf8, 0x73,
	0x6b, 0x40, 0x98, 0xf2, 0x35, 0xf3, 0x39, 0x45, 0x2f, 0x20, 0xbf, 0x8e, 0xba, 0x1f, 0x3d, 0x39,
	0x4f, 0xef, 0x9e, 0x51, 0x3b, 0x81, 0xaf, 0x23, 0xd0, 0xd7, 0x90, 0x8b, 0x9e, 0x8f, 0xa8, 0x5f,
	0x4f, 0x6e, 0x7b, 0x7a, 0x14, 0x49, 0xea, 0x24, 0xe2, 0xa3, 0x13, 0xc8, 0x50, 0xd9, 0x81, 0xe8,
	0x81, 0xf9, 0xf0, 0x8e, 0x26, 0xb5, 0x13, 0x38, 0xe4, 0x9e, 0x02, 0xe4, 0x83, 0x28, 0x73, 0xe3,
	0x8f, 0x24, 0x14, 0xae, 0xe7, 0x81, 0x0c, 0x28, 0x0b, 0x26, 0x1c, 0x8f, 0x78, 0x8c, 0x73, 0x32,
	0x9f, 0xaa, 0x62, 0x92, 0xb8, 0xa8, 0xc0, 0x2e, 0xe3, 0xbc, 0x39, 0x95, 0x32, 0x8a, 0x38, 0x91,
	0x44, 0x62, 0x19, 0x85, 0xa4, 0x50, 0x21, 0xe8, 0x04, 0x1e, 0x46, 0x59, 0x90, 0x80, 0x8a, 0x4d,
	0xe0, 0x5f, 0x1f, 0x99, 0x52, 0xec, 0xfd, 0xc8, 0x8b, 0x95, 0x33, 0x3a, 0xfa, 0x10, 0x90, 0x73,
	0x45, 0x03, 0x67, 0x41, 0x63, 0x36, 0xf9, 0x39, 0xd6, 0xd7, 0x5e, 0xe4, 0x09, 0xa9, 0x17, 0x2b,
	0x84, 0xe1, 0xc1, 0xdc, 0xe5, 0x33, 0x76, 0x45, 0x03, 0x3a, 0x27, 0xff, 0x5b, 0x73, 0xfb, 0x37,
	0xc1, 0xd7, 0x3e, 0x74, 0x08, 0x59, 0x7a, 0x45, 0x7d, 0xc1, 0xab, 0xd9, 0x5a, 0xea, 0xa0, 0x58,
	0xdf, 0xdf, 0x3d, 0xc4, 0x92, 0x3e, 0x1c, 0x51, 0x8c, 0x39, 0x64, 0x14, 0x20, 0x15, 0x31, 0x77,
	0xb9, 0x70, 0xfc, 0x99, 0x7c, 0x0e, 0xc2, 0x96, 0x15, 0x62, 0xa4, 0x27, 0x9f, 0x8a, 0xb8, 0xf6,
	0xb0, 0x53, 0x59, 0x2f, 0x2c, 0xf7, 0x63, 0x28, 0x07, 0xf4, 0xd2, 0xa3, 0x33, 0xf5, 0x7a, 0x5d,
	0xb7, 0xa6, 0x74, 0x03, 0x36, 0xa7, 0x9f, 0xff, 0xa6, 0x81, 0xfe, 0x76, 0xf2, 0x72, 0x89, 0x5b,
	0xa3, 0x21, 0xd9, 0xd1, 0xb3, 0x04, 0x9a, 0x76, 0x4b, 0xd7, 0xa4, 0x84, 0xa5, 0xd1, 0xb5, 0x1a,
	0xad, 0x50, 0xd0, 0xd2, 0xb2, 0xed, 0x5e, 0x4b, 0x4f, 0xc5, 0xc4, 0xd1, 0xe4, 0x4c, 0x4f, 0xc7,
	0xae, 0xd1, 0x04, 0xdb, 0x7a, 0x06, 0x01, 0x64, 0x55, 0x98, 0xad, 0x67, 0x91, 0x0e, 0x25, 0xe5,
	0xb1, 0x70, 0x63, 0xd2, 0xf8, 0xc1, 0xd2, 0x73, 0xe8, 0x1e, 0x94, 0x63, 0xa4, 0xdb, 0x39, 0x6f,
	0x8f, 0xf4, 0x7c, 0x7d, 0x0c, 0x69, 0xb9, 0x3a, 0xa8, 0x07, 0xf9, 0x78, 0xd3, 0xd0, 0x93, 0x3b,
	0xbf, 0x9a, 0x8f, 0x9f, 0xde, 0xba, 0xd9, 0xe1, 0x3a, 0x26, 0x8e, 0xb5, 0xd3, 0xfc, 0x5f, 0xdf,
	0x67, 0x8e, 0xcd, 0x2f, 0xcc, 0xe3, 0x69, 0x56, 0x7d, 0xe5, 0x4f, 0xfe, 0x0d, 0x00, 0x00, 0xff,
	0xff, 0x93, 0xe0, 0xfa, 0x41, 0x34, 0x08, 0x00, 0x00,
}
