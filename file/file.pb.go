// Code generated by protoc-gen-go.
// source: file/file.proto
// DO NOT EDIT!

/*
Package gnoi_file is a generated protocol buffer package.

It is generated from these files:
	file/file.proto

It has these top-level messages:
	PutRequest
	PutResponse
	GetRequest
	GetResponse
	TransferToRemoteRequest
	TransferToRemoteResponse
	StatRequest
	StatResponse
	StatInfo
	RemoveRequest
	RemoveResponse
*/
package gnoi_file

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import gnoi1 "common"
import gnoi "types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A PutRequest is used to send data to be written on a file on the target.
//
// The initial message contains an Open message. The Open message contains
// information name of the file and the file's permisssions.
//
// The remote_file must be an absolute path. If remote_file already exists on
// the target, it is overwritten, otherwise it is created. If the path to
// remote_file doesn't exist it will be created.
//
// The contents to be written are streamed through multiple messages using the
// contents field. Each message may contain up to 64KB of data.
//
// The final message of the RPC contains the hash of the file contents.
type PutRequest struct {
	// Types that are valid to be assigned to Request:
	//	*PutRequest_Open
	//	*PutRequest_Contents
	//	*PutRequest_Hash
	Request isPutRequest_Request `protobuf_oneof:"request"`
}

func (m *PutRequest) Reset()                    { *m = PutRequest{} }
func (m *PutRequest) String() string            { return proto.CompactTextString(m) }
func (*PutRequest) ProtoMessage()               {}
func (*PutRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isPutRequest_Request interface {
	isPutRequest_Request()
}

type PutRequest_Open struct {
	Open *PutRequest_Details `protobuf:"bytes,1,opt,name=open,oneof"`
}
type PutRequest_Contents struct {
	Contents []byte `protobuf:"bytes,2,opt,name=contents,proto3,oneof"`
}
type PutRequest_Hash struct {
	Hash *gnoi.HashType `protobuf:"bytes,3,opt,name=hash,oneof"`
}

func (*PutRequest_Open) isPutRequest_Request()     {}
func (*PutRequest_Contents) isPutRequest_Request() {}
func (*PutRequest_Hash) isPutRequest_Request()     {}

func (m *PutRequest) GetRequest() isPutRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *PutRequest) GetOpen() *PutRequest_Details {
	if x, ok := m.GetRequest().(*PutRequest_Open); ok {
		return x.Open
	}
	return nil
}

func (m *PutRequest) GetContents() []byte {
	if x, ok := m.GetRequest().(*PutRequest_Contents); ok {
		return x.Contents
	}
	return nil
}

func (m *PutRequest) GetHash() *gnoi.HashType {
	if x, ok := m.GetRequest().(*PutRequest_Hash); ok {
		return x.Hash
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PutRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PutRequest_OneofMarshaler, _PutRequest_OneofUnmarshaler, _PutRequest_OneofSizer, []interface{}{
		(*PutRequest_Open)(nil),
		(*PutRequest_Contents)(nil),
		(*PutRequest_Hash)(nil),
	}
}

func _PutRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PutRequest)
	// request
	switch x := m.Request.(type) {
	case *PutRequest_Open:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Open); err != nil {
			return err
		}
	case *PutRequest_Contents:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Contents)
	case *PutRequest_Hash:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Hash); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PutRequest.Request has unexpected type %T", x)
	}
	return nil
}

func _PutRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PutRequest)
	switch tag {
	case 1: // request.open
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PutRequest_Details)
		err := b.DecodeMessage(msg)
		m.Request = &PutRequest_Open{msg}
		return true, err
	case 2: // request.contents
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Request = &PutRequest_Contents{x}
		return true, err
	case 3: // request.hash
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(gnoi.HashType)
		err := b.DecodeMessage(msg)
		m.Request = &PutRequest_Hash{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PutRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PutRequest)
	// request
	switch x := m.Request.(type) {
	case *PutRequest_Open:
		s := proto.Size(x.Open)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PutRequest_Contents:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Contents)))
		n += len(x.Contents)
	case *PutRequest_Hash:
		s := proto.Size(x.Hash)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PutRequest_Details struct {
	RemoteFile string `protobuf:"bytes,1,opt,name=remote_file,json=remoteFile" json:"remote_file,omitempty"`
	// Permissions are represented as the octal format of standard UNIX
	// file permissions.
	// ex. 775: user read/write/execute, group read/write/execute,
	// global read/execute.
	Permissions uint32 `protobuf:"varint,2,opt,name=permissions" json:"permissions,omitempty"`
}

func (m *PutRequest_Details) Reset()                    { *m = PutRequest_Details{} }
func (m *PutRequest_Details) String() string            { return proto.CompactTextString(m) }
func (*PutRequest_Details) ProtoMessage()               {}
func (*PutRequest_Details) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type PutResponse struct {
}

func (m *PutResponse) Reset()                    { *m = PutResponse{} }
func (m *PutResponse) String() string            { return proto.CompactTextString(m) }
func (*PutResponse) ProtoMessage()               {}
func (*PutResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// A GetRequest specifies the remote_file to be streamed back
// to the caller. The remote_file must be an absolute path to an
// existing file.
type GetRequest struct {
	RemoteFile string `protobuf:"bytes,1,opt,name=remote_file,json=remoteFile" json:"remote_file,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// A GetResponse either contains the next set of bytes read from the
// file or, as the last message, the hash of the data.
type GetResponse struct {
	// Types that are valid to be assigned to Response:
	//	*GetResponse_Contents
	//	*GetResponse_Hash
	Response isGetResponse_Response `protobuf_oneof:"response"`
}

func (m *GetResponse) Reset()                    { *m = GetResponse{} }
func (m *GetResponse) String() string            { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()               {}
func (*GetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isGetResponse_Response interface {
	isGetResponse_Response()
}

type GetResponse_Contents struct {
	Contents []byte `protobuf:"bytes,1,opt,name=contents,proto3,oneof"`
}
type GetResponse_Hash struct {
	Hash *gnoi.HashType `protobuf:"bytes,2,opt,name=hash,oneof"`
}

func (*GetResponse_Contents) isGetResponse_Response() {}
func (*GetResponse_Hash) isGetResponse_Response()     {}

func (m *GetResponse) GetResponse() isGetResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *GetResponse) GetContents() []byte {
	if x, ok := m.GetResponse().(*GetResponse_Contents); ok {
		return x.Contents
	}
	return nil
}

func (m *GetResponse) GetHash() *gnoi.HashType {
	if x, ok := m.GetResponse().(*GetResponse_Hash); ok {
		return x.Hash
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetResponse_OneofMarshaler, _GetResponse_OneofUnmarshaler, _GetResponse_OneofSizer, []interface{}{
		(*GetResponse_Contents)(nil),
		(*GetResponse_Hash)(nil),
	}
}

func _GetResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetResponse)
	// response
	switch x := m.Response.(type) {
	case *GetResponse_Contents:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Contents)
	case *GetResponse_Hash:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Hash); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _GetResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetResponse)
	switch tag {
	case 1: // response.contents
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Response = &GetResponse_Contents{x}
		return true, err
	case 2: // response.hash
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(gnoi.HashType)
		err := b.DecodeMessage(msg)
		m.Response = &GetResponse_Hash{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetResponse)
	// response
	switch x := m.Response.(type) {
	case *GetResponse_Contents:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Contents)))
		n += len(x.Contents)
	case *GetResponse_Hash:
		s := proto.Size(x.Hash)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A TransferToRemoteRequest specifies the local path to transfer to and the
// details on where to transfer the data from. The local_path must be an
// absolute path to the file.
type TransferToRemoteRequest struct {
	LocalPath string `protobuf:"bytes,1,opt,name=local_path,json=localPath" json:"local_path,omitempty"`
	// Details to download the remote_file being requested to a remote location.
	RemoteDownload *gnoi1.RemoteDownload `protobuf:"bytes,2,opt,name=remote_download,json=remoteDownload" json:"remote_download,omitempty"`
}

func (m *TransferToRemoteRequest) Reset()                    { *m = TransferToRemoteRequest{} }
func (m *TransferToRemoteRequest) String() string            { return proto.CompactTextString(m) }
func (*TransferToRemoteRequest) ProtoMessage()               {}
func (*TransferToRemoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TransferToRemoteRequest) GetRemoteDownload() *gnoi1.RemoteDownload {
	if m != nil {
		return m.RemoteDownload
	}
	return nil
}

// A TransferToRemoteResponse contains the hash of the data transferred.
type TransferToRemoteResponse struct {
	Hash *gnoi.HashType `protobuf:"bytes,1,opt,name=hash" json:"hash,omitempty"`
}

func (m *TransferToRemoteResponse) Reset()                    { *m = TransferToRemoteResponse{} }
func (m *TransferToRemoteResponse) String() string            { return proto.CompactTextString(m) }
func (*TransferToRemoteResponse) ProtoMessage()               {}
func (*TransferToRemoteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *TransferToRemoteResponse) GetHash() *gnoi.HashType {
	if m != nil {
		return m.Hash
	}
	return nil
}

// StatRequest will list files at the provided path.
type StatRequest struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *StatRequest) Reset()                    { *m = StatRequest{} }
func (m *StatRequest) String() string            { return proto.CompactTextString(m) }
func (*StatRequest) ProtoMessage()               {}
func (*StatRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// StatResponse contains list of stat info of the provided path.
type StatResponse struct {
	Stats []*StatInfo `protobuf:"bytes,1,rep,name=stats" json:"stats,omitempty"`
}

func (m *StatResponse) Reset()                    { *m = StatResponse{} }
func (m *StatResponse) String() string            { return proto.CompactTextString(m) }
func (*StatResponse) ProtoMessage()               {}
func (*StatResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *StatResponse) GetStats() []*StatInfo {
	if m != nil {
		return m.Stats
	}
	return nil
}

// StatInfo provides a file system information about a particular path.
type StatInfo struct {
	Path         string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	LastModified uint64 `protobuf:"varint,2,opt,name=last_modified,json=lastModified" json:"last_modified,omitempty"`
	// Permissions are represented as the octal format of standard UNIX
	// file permissions.
	// ex. 775: user read/write/execute, group read/write/execute,
	// global read/execute.
	Permissions uint32 `protobuf:"varint,3,opt,name=permissions" json:"permissions,omitempty"`
	Size        uint64 `protobuf:"varint,4,opt,name=size" json:"size,omitempty"`
	// Default file creation mask. Represented as the octal format of
	// standard UNIX mask.
	Umask uint32 `protobuf:"varint,5,opt,name=umask" json:"umask,omitempty"`
}

func (m *StatInfo) Reset()                    { *m = StatInfo{} }
func (m *StatInfo) String() string            { return proto.CompactTextString(m) }
func (*StatInfo) ProtoMessage()               {}
func (*StatInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// A RemoveRequest specifies a file to be removed from the target.
type RemoveRequest struct {
	RemoteFile string `protobuf:"bytes,1,opt,name=remote_file,json=remoteFile" json:"remote_file,omitempty"`
}

func (m *RemoveRequest) Reset()                    { *m = RemoveRequest{} }
func (m *RemoveRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveRequest) ProtoMessage()               {}
func (*RemoveRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type RemoveResponse struct {
}

func (m *RemoveResponse) Reset()                    { *m = RemoveResponse{} }
func (m *RemoveResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveResponse) ProtoMessage()               {}
func (*RemoveResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func init() {
	proto.RegisterType((*PutRequest)(nil), "gnoi.file.PutRequest")
	proto.RegisterType((*PutRequest_Details)(nil), "gnoi.file.PutRequest.Details")
	proto.RegisterType((*PutResponse)(nil), "gnoi.file.PutResponse")
	proto.RegisterType((*GetRequest)(nil), "gnoi.file.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "gnoi.file.GetResponse")
	proto.RegisterType((*TransferToRemoteRequest)(nil), "gnoi.file.TransferToRemoteRequest")
	proto.RegisterType((*TransferToRemoteResponse)(nil), "gnoi.file.TransferToRemoteResponse")
	proto.RegisterType((*StatRequest)(nil), "gnoi.file.StatRequest")
	proto.RegisterType((*StatResponse)(nil), "gnoi.file.StatResponse")
	proto.RegisterType((*StatInfo)(nil), "gnoi.file.StatInfo")
	proto.RegisterType((*RemoveRequest)(nil), "gnoi.file.RemoveRequest")
	proto.RegisterType((*RemoveResponse)(nil), "gnoi.file.RemoveResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for File service

type FileClient interface {
	// Get reads and streams the contents of a file from the target.
	// The file is streamed by sequential messages, each containing up to
	// 64KB of data. A final message is sent prior to closing the stream
	// that contains the hash of the data sent. An error is returned
	// if the file does not exist or there was an error reading the file.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (File_GetClient, error)
	// TransferToRemote transfers the contents of a file from the target to a
	// specified remote location. The response contains the hash of the data
	// transferred. An error is returned if the file does not exist, the file
	// transfer fails, or if there was an error reading the file. This is a
	// blocking call until the file transfer is complete.
	TransferToRemote(ctx context.Context, in *TransferToRemoteRequest, opts ...grpc.CallOption) (*TransferToRemoteResponse, error)
	// Put streams data into a file on the target. The file is sent in
	// sequential messages, each message containing up to 64KB of data. A final
	// message must be sent that includes the hash of the data sent. An
	// error is returned if the location does not exist or there is an error
	// writing the data. If no checksum is received, the target must assume the
	// operation is incomplete and remove the partially transmitted file. The
	// target should initially write the file to a temporary location so a failure
	// does not destroy the original file.
	Put(ctx context.Context, opts ...grpc.CallOption) (File_PutClient, error)
	// Stat returns metadata about a file on the target. An error is returned
	// if the file does not exist of there is an error in accessing the metadata.
	Stat(ctx context.Context, in *StatRequest, opts ...grpc.CallOption) (*StatResponse, error)
	// Remove removes the specified file from the target. An error is
	// returned if the file does not exist, is a directory, or the remove
	// operation encounters an error (e.g., permission denied).
	Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error)
}

type fileClient struct {
	cc *grpc.ClientConn
}

func NewFileClient(cc *grpc.ClientConn) FileClient {
	return &fileClient{cc}
}

func (c *fileClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (File_GetClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_File_serviceDesc.Streams[0], c.cc, "/gnoi.file.File/Get", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type File_GetClient interface {
	Recv() (*GetResponse, error)
	grpc.ClientStream
}

type fileGetClient struct {
	grpc.ClientStream
}

func (x *fileGetClient) Recv() (*GetResponse, error) {
	m := new(GetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileClient) TransferToRemote(ctx context.Context, in *TransferToRemoteRequest, opts ...grpc.CallOption) (*TransferToRemoteResponse, error) {
	out := new(TransferToRemoteResponse)
	err := grpc.Invoke(ctx, "/gnoi.file.File/TransferToRemote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileClient) Put(ctx context.Context, opts ...grpc.CallOption) (File_PutClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_File_serviceDesc.Streams[1], c.cc, "/gnoi.file.File/Put", opts...)
	if err != nil {
		return nil, err
	}
	x := &filePutClient{stream}
	return x, nil
}

type File_PutClient interface {
	Send(*PutRequest) error
	CloseAndRecv() (*PutResponse, error)
	grpc.ClientStream
}

type filePutClient struct {
	grpc.ClientStream
}

func (x *filePutClient) Send(m *PutRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *filePutClient) CloseAndRecv() (*PutResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PutResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileClient) Stat(ctx context.Context, in *StatRequest, opts ...grpc.CallOption) (*StatResponse, error) {
	out := new(StatResponse)
	err := grpc.Invoke(ctx, "/gnoi.file.File/Stat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileClient) Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error) {
	out := new(RemoveResponse)
	err := grpc.Invoke(ctx, "/gnoi.file.File/Remove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for File service

type FileServer interface {
	// Get reads and streams the contents of a file from the target.
	// The file is streamed by sequential messages, each containing up to
	// 64KB of data. A final message is sent prior to closing the stream
	// that contains the hash of the data sent. An error is returned
	// if the file does not exist or there was an error reading the file.
	Get(*GetRequest, File_GetServer) error
	// TransferToRemote transfers the contents of a file from the target to a
	// specified remote location. The response contains the hash of the data
	// transferred. An error is returned if the file does not exist, the file
	// transfer fails, or if there was an error reading the file. This is a
	// blocking call until the file transfer is complete.
	TransferToRemote(context.Context, *TransferToRemoteRequest) (*TransferToRemoteResponse, error)
	// Put streams data into a file on the target. The file is sent in
	// sequential messages, each message containing up to 64KB of data. A final
	// message must be sent that includes the hash of the data sent. An
	// error is returned if the location does not exist or there is an error
	// writing the data. If no checksum is received, the target must assume the
	// operation is incomplete and remove the partially transmitted file. The
	// target should initially write the file to a temporary location so a failure
	// does not destroy the original file.
	Put(File_PutServer) error
	// Stat returns metadata about a file on the target. An error is returned
	// if the file does not exist of there is an error in accessing the metadata.
	Stat(context.Context, *StatRequest) (*StatResponse, error)
	// Remove removes the specified file from the target. An error is
	// returned if the file does not exist, is a directory, or the remove
	// operation encounters an error (e.g., permission denied).
	Remove(context.Context, *RemoveRequest) (*RemoveResponse, error)
}

func RegisterFileServer(s *grpc.Server, srv FileServer) {
	s.RegisterService(&_File_serviceDesc, srv)
}

func _File_Get_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileServer).Get(m, &fileGetServer{stream})
}

type File_GetServer interface {
	Send(*GetResponse) error
	grpc.ServerStream
}

type fileGetServer struct {
	grpc.ServerStream
}

func (x *fileGetServer) Send(m *GetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _File_TransferToRemote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferToRemoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServer).TransferToRemote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.file.File/TransferToRemote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServer).TransferToRemote(ctx, req.(*TransferToRemoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _File_Put_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileServer).Put(&filePutServer{stream})
}

type File_PutServer interface {
	SendAndClose(*PutResponse) error
	Recv() (*PutRequest, error)
	grpc.ServerStream
}

type filePutServer struct {
	grpc.ServerStream
}

func (x *filePutServer) SendAndClose(m *PutResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *filePutServer) Recv() (*PutRequest, error) {
	m := new(PutRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _File_Stat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServer).Stat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.file.File/Stat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServer).Stat(ctx, req.(*StatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _File_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.file.File/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServer).Remove(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _File_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gnoi.file.File",
	HandlerType: (*FileServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TransferToRemote",
			Handler:    _File_TransferToRemote_Handler,
		},
		{
			MethodName: "Stat",
			Handler:    _File_Stat_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _File_Remove_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Get",
			Handler:       _File_Get_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Put",
			Handler:       _File_Put_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "file/file.proto",
}

func init() { proto.RegisterFile("file/file.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 575 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x54, 0x5d, 0x6f, 0xd3, 0x30,
	0x14, 0x6d, 0xda, 0x74, 0x6b, 0x6f, 0xda, 0x6e, 0x78, 0x63, 0x0b, 0x11, 0x13, 0xc5, 0xe3, 0xa1,
	0x3c, 0x90, 0x96, 0xee, 0x85, 0x3d, 0x30, 0xa4, 0x6a, 0x62, 0x45, 0x02, 0xa9, 0x0a, 0x7d, 0x9d,
	0x2a, 0xd3, 0xba, 0x34, 0x22, 0x89, 0x43, 0xec, 0x32, 0x8d, 0x3f, 0xc1, 0x7f, 0x43, 0xe2, 0x95,
	0xdf, 0x82, 0x6c, 0x27, 0x6d, 0xfa, 0xb1, 0xb1, 0x97, 0x34, 0x39, 0x3e, 0x3e, 0xf7, 0x9c, 0xeb,
	0xeb, 0xc2, 0xde, 0xd4, 0x0f, 0x68, 0x5b, 0x3e, 0xdc, 0x38, 0x61, 0x82, 0xa1, 0xea, 0xd7, 0x88,
	0xf9, 0xae, 0x04, 0x9c, 0x83, 0x31, 0x0b, 0x43, 0x16, 0xb5, 0xf5, 0x8f, 0x5e, 0x77, 0x1e, 0x89,
	0xdb, 0x98, 0xf2, 0xb6, 0x7a, 0x6a, 0x08, 0xff, 0x35, 0x00, 0x06, 0x73, 0xe1, 0xd1, 0xef, 0x73,
	0xca, 0x05, 0x3a, 0x03, 0x93, 0xc5, 0x34, 0xb2, 0x8d, 0xa6, 0xd1, 0xb2, 0xba, 0x27, 0xee, 0x42,
	0xd0, 0x5d, 0x92, 0xdc, 0x4b, 0x2a, 0x88, 0x1f, 0xf0, 0x7e, 0xc1, 0x53, 0x64, 0xf4, 0x14, 0x2a,
	0x63, 0x16, 0x09, 0x1a, 0x09, 0x6e, 0x17, 0x9b, 0x46, 0xab, 0xd6, 0x2f, 0x78, 0x0b, 0x04, 0xbd,
	0x00, 0x73, 0x46, 0xf8, 0xcc, 0x2e, 0x29, 0xc9, 0x86, 0x96, 0xec, 0x13, 0x3e, 0x1b, 0xde, 0xc6,
	0x54, 0x6a, 0xc8, 0x55, 0xe7, 0x23, 0xec, 0xa6, 0xb2, 0xe8, 0x19, 0x58, 0x09, 0x0d, 0x99, 0xa0,
	0x23, 0x59, 0x58, 0x59, 0xa9, 0x7a, 0xa0, 0xa1, 0xf7, 0x7e, 0x40, 0x51, 0x13, 0xac, 0x98, 0x26,
	0xa1, 0xcf, 0xb9, 0xcf, 0x22, 0x5d, 0xb2, 0xee, 0xe5, 0xa1, 0x5e, 0x15, 0x76, 0x13, 0x6d, 0x16,
	0xd7, 0xc1, 0x52, 0xd6, 0x79, 0xcc, 0x22, 0x4e, 0xf1, 0x2b, 0x80, 0x2b, 0xba, 0x88, 0xfb, 0xbf,
	0x52, 0xf8, 0x1a, 0x2c, 0x45, 0xd7, 0xbb, 0x57, 0x92, 0x1a, 0x77, 0x26, 0x2d, 0xde, 0x97, 0xb4,
	0x07, 0x50, 0x49, 0x32, 0x37, 0x37, 0x70, 0x3c, 0x4c, 0x48, 0xc4, 0xa7, 0x34, 0x19, 0x32, 0x4f,
	0x95, 0xcd, 0xac, 0x9d, 0x00, 0x04, 0x6c, 0x4c, 0x82, 0x51, 0x4c, 0xc4, 0x2c, 0x75, 0x56, 0x55,
	0xc8, 0x80, 0x88, 0x19, 0x7a, 0x0b, 0x7b, 0xa9, 0xf3, 0x09, 0xbb, 0x89, 0x02, 0x46, 0x26, 0x69,
	0xd9, 0x43, 0x5d, 0x56, 0x8b, 0x5d, 0xa6, 0x6b, 0x5e, 0x23, 0x59, 0xf9, 0xc6, 0x17, 0x60, 0x6f,
	0x16, 0x4e, 0x43, 0xe2, 0x34, 0x86, 0xb1, 0x2d, 0x86, 0x0e, 0x81, 0x9f, 0x83, 0xf5, 0x59, 0x90,
	0x45, 0x1f, 0x11, 0x98, 0x39, 0x9b, 0xea, 0x1d, 0x9f, 0x43, 0x4d, 0x53, 0x52, 0xd9, 0x97, 0x50,
	0xe6, 0x82, 0xa8, 0xc6, 0x95, 0x5a, 0x56, 0xf7, 0x20, 0x37, 0x5b, 0x92, 0xf7, 0x21, 0x9a, 0x32,
	0x4f, 0x33, 0xf0, 0x2f, 0x03, 0x2a, 0x19, 0xb6, 0x4d, 0x1b, 0x9d, 0x42, 0x3d, 0x20, 0x5c, 0x8c,
	0x42, 0x36, 0xf1, 0xa7, 0x3e, 0xd5, 0xd9, 0x4d, 0xaf, 0x26, 0xc1, 0x4f, 0x29, 0xb6, 0x3e, 0x26,
	0xa5, 0x8d, 0x31, 0x91, 0xd2, 0xdc, 0xff, 0x49, 0x6d, 0x53, 0xed, 0x56, 0xef, 0xe8, 0x10, 0xca,
	0xf3, 0x90, 0xf0, 0x6f, 0x76, 0x59, 0xf1, 0xf5, 0x07, 0xee, 0x40, 0x5d, 0x76, 0xe9, 0x07, 0x7d,
	0xf0, 0xe4, 0xec, 0x43, 0x23, 0xdb, 0xa1, 0x1b, 0xd0, 0xfd, 0x53, 0x04, 0x53, 0xcd, 0xef, 0x1b,
	0x28, 0x5d, 0x51, 0x81, 0x1e, 0xe7, 0x3a, 0xb0, 0x9c, 0x49, 0xe7, 0x68, 0x1d, 0x4e, 0x67, 0xa5,
	0xd0, 0x31, 0xd0, 0x35, 0xec, 0xaf, 0x1f, 0x1b, 0xc2, 0x39, 0xfe, 0x1d, 0xc3, 0xe4, 0x9c, 0xde,
	0xcb, 0xc9, 0x0a, 0x48, 0x63, 0x83, 0xf9, 0xaa, 0xb1, 0xe5, 0xb5, 0x5f, 0x31, 0x96, 0xbf, 0x52,
	0x85, 0x96, 0x81, 0xce, 0xc1, 0x94, 0x07, 0x86, 0x8e, 0xd6, 0x4e, 0x35, 0xdb, 0x7b, 0xbc, 0x81,
	0x2f, 0x8a, 0xbe, 0x83, 0x1d, 0xdd, 0x28, 0x64, 0xe7, 0x48, 0x2b, 0xdd, 0x76, 0x9e, 0x6c, 0x59,
	0xc9, 0x04, 0x7a, 0x95, 0xdf, 0x17, 0xe5, 0x8e, 0xfb, 0xda, 0xed, 0x7c, 0xd9, 0x51, 0xff, 0x69,
	0x67, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xfd, 0xd9, 0x93, 0x47, 0x19, 0x05, 0x00, 0x00,
}
