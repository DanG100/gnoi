// Code generated by protoc-gen-go.
// source: diag/diag.proto
// DO NOT EDIT!

/*
Package gnoi_diag is a generated protocol buffer package.

It is generated from these files:
	diag/diag.proto

It has these top-level messages:
	StartBERTRequest
	StartBERTResponse
	StopBERTRequest
	StopBERTResponse
	GetBERTResultRequest
	GetBERTResultResponse
*/
package gnoi_diag

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import gnoi "types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Common sequence generating monic polynomials used for PRBS.
type PrbsPolynomial int32

const (
	PrbsPolynomial_PRBS_POLYNOMIAL_UNKNOWN PrbsPolynomial = 0
	PrbsPolynomial_PRBS_POLYNOMIAL_PRBS7   PrbsPolynomial = 1
	PrbsPolynomial_PRBS_POLYNOMIAL_PRBS9   PrbsPolynomial = 2
	PrbsPolynomial_PRBS_POLYNOMIAL_PRBS15  PrbsPolynomial = 3
	PrbsPolynomial_PRBS_POLYNOMIAL_PRBS20  PrbsPolynomial = 4
	PrbsPolynomial_PRBS_POLYNOMIAL_PRBS23  PrbsPolynomial = 5
	PrbsPolynomial_PRBS_POLYNOMIAL_PRBS31  PrbsPolynomial = 6
)

var PrbsPolynomial_name = map[int32]string{
	0: "PRBS_POLYNOMIAL_UNKNOWN",
	1: "PRBS_POLYNOMIAL_PRBS7",
	2: "PRBS_POLYNOMIAL_PRBS9",
	3: "PRBS_POLYNOMIAL_PRBS15",
	4: "PRBS_POLYNOMIAL_PRBS20",
	5: "PRBS_POLYNOMIAL_PRBS23",
	6: "PRBS_POLYNOMIAL_PRBS31",
}
var PrbsPolynomial_value = map[string]int32{
	"PRBS_POLYNOMIAL_UNKNOWN": 0,
	"PRBS_POLYNOMIAL_PRBS7":   1,
	"PRBS_POLYNOMIAL_PRBS9":   2,
	"PRBS_POLYNOMIAL_PRBS15":  3,
	"PRBS_POLYNOMIAL_PRBS20":  4,
	"PRBS_POLYNOMIAL_PRBS23":  5,
	"PRBS_POLYNOMIAL_PRBS31":  6,
}

func (x PrbsPolynomial) String() string {
	return proto.EnumName(PrbsPolynomial_name, int32(x))
}
func (PrbsPolynomial) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Status returned for each per-port BERT request.
type BertStatus int32

const (
	// default invalid choice.
	BertStatus_BERT_STATUS_UNKNOWN BertStatus = 0
	// BERT requests (Start, Stop, GetStatus) were processed successfully.
	BertStatus_BERT_STATUS_OK BertStatus = 1
	// The specified port was not found.
	BertStatus_BERT_STATUS_NON_EXISTENT_PORT BertStatus = 2
	// HW error was encountered while performing BERT operation.
	BertStatus_BERT_STATUS_HARDWARE_ACCESS_ERROR BertStatus = 3
	// PRBS generating polynomial is not supported by the target.
	BertStatus_BERT_STATUS_UNSUPPORTED_PRBS_POLYNOMIAL BertStatus = 4
	// There is already a BERT running on the specified port. Returned when
	// `StartBert` RPC tries to add run BERT on an already in-use port.
	BertStatus_BERT_STATUS_PORT_ALREADY_IN_BERT BertStatus = 5
	// There is no BERT running on the specified port. Returned when `StopBert`
	// or `GetBertResult` RPC was called for an idle port.
	BertStatus_BERT_STATUS_PORT_NOT_RUNNING_BERT BertStatus = 6
	// The specified test duration is too small.
	BertStatus_BERT_STATUS_TEST_DURATION_TOO_SHORT BertStatus = 7
	// The specified test duration is larger than maximum allowed.
	BertStatus_BERT_STATUS_TEST_DURATION_TOO_LONG BertStatus = 8
	// The given BERT operation ID is not known. Returned for `StopBert` and
	// `GetBertResult` RPCs.
	BertStatus_BERT_STATUS_OPERATION_ID_NOT_FOUND BertStatus = 9
	// The given BERT operation ID is already in use. Returned when `StartBert`
	// RPC uses an ID which is already memorized for a BERT operation.
	BertStatus_BERT_STATUS_OPERATION_ID_IN_USE BertStatus = 10
	// Failure to get the peer lock.
	BertStatus_BERT_STATUS_PEER_LOCK_FAILURE BertStatus = 11
	// Lost the peer lock after locking once.
	BertStatus_BERT_STATUS_PEER_LOCK_LOST BertStatus = 12
	// Misc internal errors that cannot be categorized by any of the previous
	// error codes.
	BertStatus_BERT_STATUS_INTERNAL_ERROR BertStatus = 13
)

var BertStatus_name = map[int32]string{
	0:  "BERT_STATUS_UNKNOWN",
	1:  "BERT_STATUS_OK",
	2:  "BERT_STATUS_NON_EXISTENT_PORT",
	3:  "BERT_STATUS_HARDWARE_ACCESS_ERROR",
	4:  "BERT_STATUS_UNSUPPORTED_PRBS_POLYNOMIAL",
	5:  "BERT_STATUS_PORT_ALREADY_IN_BERT",
	6:  "BERT_STATUS_PORT_NOT_RUNNING_BERT",
	7:  "BERT_STATUS_TEST_DURATION_TOO_SHORT",
	8:  "BERT_STATUS_TEST_DURATION_TOO_LONG",
	9:  "BERT_STATUS_OPERATION_ID_NOT_FOUND",
	10: "BERT_STATUS_OPERATION_ID_IN_USE",
	11: "BERT_STATUS_PEER_LOCK_FAILURE",
	12: "BERT_STATUS_PEER_LOCK_LOST",
	13: "BERT_STATUS_INTERNAL_ERROR",
}
var BertStatus_value = map[string]int32{
	"BERT_STATUS_UNKNOWN":                     0,
	"BERT_STATUS_OK":                          1,
	"BERT_STATUS_NON_EXISTENT_PORT":           2,
	"BERT_STATUS_HARDWARE_ACCESS_ERROR":       3,
	"BERT_STATUS_UNSUPPORTED_PRBS_POLYNOMIAL": 4,
	"BERT_STATUS_PORT_ALREADY_IN_BERT":        5,
	"BERT_STATUS_PORT_NOT_RUNNING_BERT":       6,
	"BERT_STATUS_TEST_DURATION_TOO_SHORT":     7,
	"BERT_STATUS_TEST_DURATION_TOO_LONG":      8,
	"BERT_STATUS_OPERATION_ID_NOT_FOUND":      9,
	"BERT_STATUS_OPERATION_ID_IN_USE":         10,
	"BERT_STATUS_PEER_LOCK_FAILURE":           11,
	"BERT_STATUS_PEER_LOCK_LOST":              12,
	"BERT_STATUS_INTERNAL_ERROR":              13,
}

func (x BertStatus) String() string {
	return proto.EnumName(BertStatus_name, int32(x))
}
func (BertStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type StartBERTRequest struct {
	// Unique BERT operation ID specified by the client. Multiple BERTs run on
	// different ports can have the same BERT operation ID. This ID will be used
	// later to stop the operation and/or get its results.
	// TODO: Investigate whether we can use numerical IDs instead.
	BertOperationId string `protobuf:"bytes,1,opt,name=bert_operation_id,json=bertOperationId" json:"bert_operation_id,omitempty"`
	// All the per-port BERTs that are considered one BERT operation and have the
	// same BERT operation ID.
	PerPortRequests []*StartBERTRequest_PerPortRequest `protobuf:"bytes,2,rep,name=per_port_requests,json=perPortRequests" json:"per_port_requests,omitempty"`
}

func (m *StartBERTRequest) Reset()                    { *m = StartBERTRequest{} }
func (m *StartBERTRequest) String() string            { return proto.CompactTextString(m) }
func (*StartBERTRequest) ProtoMessage()               {}
func (*StartBERTRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *StartBERTRequest) GetPerPortRequests() []*StartBERTRequest_PerPortRequest {
	if m != nil {
		return m.PerPortRequests
	}
	return nil
}

// Per port BERT start requests.
type StartBERTRequest_PerPortRequest struct {
	// Path to the interface corresponding to the port.
	Interface *gnoi.Path `protobuf:"bytes,1,opt,name=interface" json:"interface,omitempty"`
	// The selected PRBS generating polynomial for BERT.
	PrbsPolynomial PrbsPolynomial `protobuf:"varint,2,opt,name=prbs_polynomial,json=prbsPolynomial,enum=gnoi.diag.PrbsPolynomial" json:"prbs_polynomial,omitempty"`
	// BERT duration in seconds. Must be a positive number.
	TestDurationInSecs uint32 `protobuf:"varint,3,opt,name=test_duration_in_secs,json=testDurationInSecs" json:"test_duration_in_secs,omitempty"`
}

func (m *StartBERTRequest_PerPortRequest) Reset()         { *m = StartBERTRequest_PerPortRequest{} }
func (m *StartBERTRequest_PerPortRequest) String() string { return proto.CompactTextString(m) }
func (*StartBERTRequest_PerPortRequest) ProtoMessage()    {}
func (*StartBERTRequest_PerPortRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0}
}

func (m *StartBERTRequest_PerPortRequest) GetInterface() *gnoi.Path {
	if m != nil {
		return m.Interface
	}
	return nil
}

type StartBERTResponse struct {
	// The same BERT operation ID given by the request.
	BertOperationId string `protobuf:"bytes,1,opt,name=bert_operation_id,json=bertOperationId" json:"bert_operation_id,omitempty"`
	// Captures the results of starting BERT on a per-port basis.
	PerPortResponses []*StartBERTResponse_PerPortResponse `protobuf:"bytes,2,rep,name=per_port_responses,json=perPortResponses" json:"per_port_responses,omitempty"`
}

func (m *StartBERTResponse) Reset()                    { *m = StartBERTResponse{} }
func (m *StartBERTResponse) String() string            { return proto.CompactTextString(m) }
func (*StartBERTResponse) ProtoMessage()               {}
func (*StartBERTResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StartBERTResponse) GetPerPortResponses() []*StartBERTResponse_PerPortResponse {
	if m != nil {
		return m.PerPortResponses
	}
	return nil
}

// Per-port BERT start responses.
type StartBERTResponse_PerPortResponse struct {
	// Path to the interface corresponding to the port.
	Interface *gnoi.Path `protobuf:"bytes,1,opt,name=interface" json:"interface,omitempty"`
	// BERT start status for this port.
	Status BertStatus `protobuf:"varint,2,opt,name=status,enum=gnoi.diag.BertStatus" json:"status,omitempty"`
}

func (m *StartBERTResponse_PerPortResponse) Reset()         { *m = StartBERTResponse_PerPortResponse{} }
func (m *StartBERTResponse_PerPortResponse) String() string { return proto.CompactTextString(m) }
func (*StartBERTResponse_PerPortResponse) ProtoMessage()    {}
func (*StartBERTResponse_PerPortResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{1, 0}
}

func (m *StartBERTResponse_PerPortResponse) GetInterface() *gnoi.Path {
	if m != nil {
		return m.Interface
	}
	return nil
}

type StopBERTRequest struct {
	// The same BERT operation ID given when BERT operation was started.
	BertOperationId string `protobuf:"bytes,1,opt,name=bert_operation_id,json=bertOperationId" json:"bert_operation_id,omitempty"`
	// All the per-port BERTs that need to be stopped. Must be part of the BERT
	// operation specified by the `bert_operation_id` above.
	PerPortRequests []*StopBERTRequest_PerPortRequest `protobuf:"bytes,2,rep,name=per_port_requests,json=perPortRequests" json:"per_port_requests,omitempty"`
}

func (m *StopBERTRequest) Reset()                    { *m = StopBERTRequest{} }
func (m *StopBERTRequest) String() string            { return proto.CompactTextString(m) }
func (*StopBERTRequest) ProtoMessage()               {}
func (*StopBERTRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *StopBERTRequest) GetPerPortRequests() []*StopBERTRequest_PerPortRequest {
	if m != nil {
		return m.PerPortRequests
	}
	return nil
}

// Per-port BERT stop requests.
type StopBERTRequest_PerPortRequest struct {
	// Path to the interface corresponding to the port.
	Interface *gnoi.Path `protobuf:"bytes,1,opt,name=interface" json:"interface,omitempty"`
}

func (m *StopBERTRequest_PerPortRequest) Reset()         { *m = StopBERTRequest_PerPortRequest{} }
func (m *StopBERTRequest_PerPortRequest) String() string { return proto.CompactTextString(m) }
func (*StopBERTRequest_PerPortRequest) ProtoMessage()    {}
func (*StopBERTRequest_PerPortRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 0}
}

func (m *StopBERTRequest_PerPortRequest) GetInterface() *gnoi.Path {
	if m != nil {
		return m.Interface
	}
	return nil
}

type StopBERTResponse struct {
	// The same BERT operation ID given by the request.
	BertOperationId string `protobuf:"bytes,1,opt,name=bert_operation_id,json=bertOperationId" json:"bert_operation_id,omitempty"`
	// Captures the results of stopping BERT on a per-port basis.
	PerPortResponses []*StopBERTResponse_PerPortResponse `protobuf:"bytes,2,rep,name=per_port_responses,json=perPortResponses" json:"per_port_responses,omitempty"`
}

func (m *StopBERTResponse) Reset()                    { *m = StopBERTResponse{} }
func (m *StopBERTResponse) String() string            { return proto.CompactTextString(m) }
func (*StopBERTResponse) ProtoMessage()               {}
func (*StopBERTResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *StopBERTResponse) GetPerPortResponses() []*StopBERTResponse_PerPortResponse {
	if m != nil {
		return m.PerPortResponses
	}
	return nil
}

// Per-port BERT stop responses.
type StopBERTResponse_PerPortResponse struct {
	// Path to the interface corresponding to the port.
	Interface *gnoi.Path `protobuf:"bytes,1,opt,name=interface" json:"interface,omitempty"`
	// BERT stop status for this port.
	Status BertStatus `protobuf:"varint,2,opt,name=status,enum=gnoi.diag.BertStatus" json:"status,omitempty"`
}

func (m *StopBERTResponse_PerPortResponse) Reset()         { *m = StopBERTResponse_PerPortResponse{} }
func (m *StopBERTResponse_PerPortResponse) String() string { return proto.CompactTextString(m) }
func (*StopBERTResponse_PerPortResponse) ProtoMessage()    {}
func (*StopBERTResponse_PerPortResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{3, 0}
}

func (m *StopBERTResponse_PerPortResponse) GetInterface() *gnoi.Path {
	if m != nil {
		return m.Interface
	}
	return nil
}

// TODO: If there is no use case to get the BERT results for all the ports
// independent of the bert_operation_id, we can simplify this message and
// return the results for all the ports associated with an operation ID.
type GetBERTResultRequest struct {
	// The same BERT operation ID given when BERT operation was started.
	BertOperationId string `protobuf:"bytes,1,opt,name=bert_operation_id,json=bertOperationId" json:"bert_operation_id,omitempty"`
	// All the per-port BERTs result of which we want to query. Must be part of
	// the BERT operation specified by the `bert_operation_id` above.
	PerPortRequests []*GetBERTResultRequest_PerPortRequest `protobuf:"bytes,2,rep,name=per_port_requests,json=perPortRequests" json:"per_port_requests,omitempty"`
	// If set to true, the results for all the per-port BERTs will be returned.
	// `bert_operation_id` and `per_port_requests` will be ignored will be
	// ignored in that case.
	ResultFromAllPorts bool `protobuf:"varint,3,opt,name=result_from_all_ports,json=resultFromAllPorts" json:"result_from_all_ports,omitempty"`
}

func (m *GetBERTResultRequest) Reset()                    { *m = GetBERTResultRequest{} }
func (m *GetBERTResultRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBERTResultRequest) ProtoMessage()               {}
func (*GetBERTResultRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GetBERTResultRequest) GetPerPortRequests() []*GetBERTResultRequest_PerPortRequest {
	if m != nil {
		return m.PerPortRequests
	}
	return nil
}

// Per-port BERT get result requests.
type GetBERTResultRequest_PerPortRequest struct {
	// Path to the interface corresponding to the port.
	Interface *gnoi.Path `protobuf:"bytes,1,opt,name=interface" json:"interface,omitempty"`
}

func (m *GetBERTResultRequest_PerPortRequest) Reset()         { *m = GetBERTResultRequest_PerPortRequest{} }
func (m *GetBERTResultRequest_PerPortRequest) String() string { return proto.CompactTextString(m) }
func (*GetBERTResultRequest_PerPortRequest) ProtoMessage()    {}
func (*GetBERTResultRequest_PerPortRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

func (m *GetBERTResultRequest_PerPortRequest) GetInterface() *gnoi.Path {
	if m != nil {
		return m.Interface
	}
	return nil
}

type GetBERTResultResponse struct {
	// Captures the BERT results on a per-port basis.
	PerPortResponses []*GetBERTResultResponse_PerPortResponse `protobuf:"bytes,1,rep,name=per_port_responses,json=perPortResponses" json:"per_port_responses,omitempty"`
}

func (m *GetBERTResultResponse) Reset()                    { *m = GetBERTResultResponse{} }
func (m *GetBERTResultResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBERTResultResponse) ProtoMessage()               {}
func (*GetBERTResultResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetBERTResultResponse) GetPerPortResponses() []*GetBERTResultResponse_PerPortResponse {
	if m != nil {
		return m.PerPortResponses
	}
	return nil
}

// Per-port BERT results/status.
type GetBERTResultResponse_PerPortResponse struct {
	// Path to the interface corresponding to the port.
	Interface *gnoi.Path `protobuf:"bytes,1,opt,name=interface" json:"interface,omitempty"`
	// BERT result get status for this port. Only if the status is
	// BERT_STATUS_OK are the rest of the fields meaningful.
	Status BertStatus `protobuf:"varint,2,opt,name=status,enum=gnoi.diag.BertStatus" json:"status,omitempty"`
	// The ID of the BERT operation running on this port. Since the caller
	// can query the BERT results for all the ports, ID can potentially be
	// different for different ports.
	BertOperationId string `protobuf:"bytes,3,opt,name=bert_operation_id,json=bertOperationId" json:"bert_operation_id,omitempty"`
	// The selected PRBS generating polynomial for BERT on this port.
	PrbsPolynomial PrbsPolynomial `protobuf:"varint,4,opt,name=prbs_polynomial,json=prbsPolynomial,enum=gnoi.diag.PrbsPolynomial" json:"prbs_polynomial,omitempty"`
	// The last time BERT started on this port.
	LastBertStartTimestamp uint64 `protobuf:"varint,5,opt,name=last_bert_start_timestamp,json=lastBertStartTimestamp" json:"last_bert_start_timestamp,omitempty"`
	// The last time BERT results were read for this port.
	LastBertGetResultTimestamp uint64 `protobuf:"varint,6,opt,name=last_bert_get_result_timestamp,json=lastBertGetResultTimestamp" json:"last_bert_get_result_timestamp,omitempty"`
	// Indicate whether BERT peer lock has was established. If false,
	// `bert_lock_lost`, `error_count_per_minute`, and `total_errors` will not
	// be meaningful.
	PeerLockEstablished bool `protobuf:"varint,7,opt,name=peer_lock_established,json=peerLockEstablished" json:"peer_lock_established,omitempty"`
	// Indicate whether BERT peer lock was lost after being established
	// once.
	PeerLockLost bool `protobuf:"varint,8,opt,name=peer_lock_lost,json=peerLockLost" json:"peer_lock_lost,omitempty"`
	// Sequence of bit errors per min since lock was established.
	ErrorCountPerMinute []uint32 `protobuf:"varint,9,rep,packed,name=error_count_per_minute,json=errorCountPerMinute" json:"error_count_per_minute,omitempty"`
	// Total number of bit errors accumulated since lock was established.
	TotalErrors uint64 `protobuf:"varint,10,opt,name=total_errors,json=totalErrors" json:"total_errors,omitempty"`
}

func (m *GetBERTResultResponse_PerPortResponse) Reset()         { *m = GetBERTResultResponse_PerPortResponse{} }
func (m *GetBERTResultResponse_PerPortResponse) String() string { return proto.CompactTextString(m) }
func (*GetBERTResultResponse_PerPortResponse) ProtoMessage()    {}
func (*GetBERTResultResponse_PerPortResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0}
}

func (m *GetBERTResultResponse_PerPortResponse) GetInterface() *gnoi.Path {
	if m != nil {
		return m.Interface
	}
	return nil
}

func init() {
	proto.RegisterType((*StartBERTRequest)(nil), "gnoi.diag.StartBERTRequest")
	proto.RegisterType((*StartBERTRequest_PerPortRequest)(nil), "gnoi.diag.StartBERTRequest.PerPortRequest")
	proto.RegisterType((*StartBERTResponse)(nil), "gnoi.diag.StartBERTResponse")
	proto.RegisterType((*StartBERTResponse_PerPortResponse)(nil), "gnoi.diag.StartBERTResponse.PerPortResponse")
	proto.RegisterType((*StopBERTRequest)(nil), "gnoi.diag.StopBERTRequest")
	proto.RegisterType((*StopBERTRequest_PerPortRequest)(nil), "gnoi.diag.StopBERTRequest.PerPortRequest")
	proto.RegisterType((*StopBERTResponse)(nil), "gnoi.diag.StopBERTResponse")
	proto.RegisterType((*StopBERTResponse_PerPortResponse)(nil), "gnoi.diag.StopBERTResponse.PerPortResponse")
	proto.RegisterType((*GetBERTResultRequest)(nil), "gnoi.diag.GetBERTResultRequest")
	proto.RegisterType((*GetBERTResultRequest_PerPortRequest)(nil), "gnoi.diag.GetBERTResultRequest.PerPortRequest")
	proto.RegisterType((*GetBERTResultResponse)(nil), "gnoi.diag.GetBERTResultResponse")
	proto.RegisterType((*GetBERTResultResponse_PerPortResponse)(nil), "gnoi.diag.GetBERTResultResponse.PerPortResponse")
	proto.RegisterEnum("gnoi.diag.PrbsPolynomial", PrbsPolynomial_name, PrbsPolynomial_value)
	proto.RegisterEnum("gnoi.diag.BertStatus", BertStatus_name, BertStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Diag service

type DiagClient interface {
	// Starts BERT operation on a set of ports. Each BERT operation is uniquely
	// identified by an ID, which is given by the caller. The caller can then
	// use this ID (as well as the list of the ports) to stop the BERT operation
	// and/or get the BERT results. This RPC is expected to return an error status
	// in the following situations:
	// - When BERT operation is supported on none of the ports specified by
	//   the request.
	// - When BERT is already in progress on any port specified by the request.
	// - In case of any low-level HW/SW internal errors.
	// The RPC returns an OK status of none of these situations is encountered.
	StartBERT(ctx context.Context, in *StartBERTRequest, opts ...grpc.CallOption) (*StartBERTResponse, error)
	// Stops an already in-progress BERT operation on a set of ports. The caller
	// uses the BERT operation ID it previously used when starting the operation
	// to stop it. The RPC is expected to return an error status in the following
	// situations:
	// - When there is at least one BERT operation in progress on a port which
	//   cannot be stopped in the middle of the operation (either due to lack of
	//   support or internal problems).
	// - When no BERT operation, which matches the given BERT operation ID, is in
	//   progress or completed on any of the ports specified by the request.
	// - When the BERT operation ID does not match the in progress or completed
	//   BERT operation on any of the ports specified by the request.
	// The RPC returns an OK status of none of these situations is encountered.
	// Note that a BERT operation is considered completed if the device has a
	// record/history of it. Also note that it is OK to receive a stop request for
	// a port which has completed BERT, as long as the recorded BERT operation ID
	// matches the one specified by the request.
	StopBERT(ctx context.Context, in *StopBERTRequest, opts ...grpc.CallOption) (*StopBERTResponse, error)
	// Gets BERT results during the BERT operation or after it completes. The
	// caller uses the BERT operation ID it previously used when starting the
	// operation to query it. The device is expected to keep the results for
	// last N BERT operations for some amount of time, as specified by the
	// product requirement. This RPC is expected to return error status in the
	// following situations:
	// - When no BERT operation, which matches the given BERT operation ID, is in
	//   progress or completed on any of the ports specified by the request.
	// - When the BERT operation ID does not match the in progress or completed
	//   BERT operation on any of the ports specified by the request.
	// The RPC returns an OK status of none of these situations is encountered.
	// Note that a BERT operation is considered completed if device has a
	// record of it.
	GetBERTResult(ctx context.Context, in *GetBERTResultRequest, opts ...grpc.CallOption) (*GetBERTResultResponse, error)
}

type diagClient struct {
	cc *grpc.ClientConn
}

func NewDiagClient(cc *grpc.ClientConn) DiagClient {
	return &diagClient{cc}
}

func (c *diagClient) StartBERT(ctx context.Context, in *StartBERTRequest, opts ...grpc.CallOption) (*StartBERTResponse, error) {
	out := new(StartBERTResponse)
	err := grpc.Invoke(ctx, "/gnoi.diag.Diag/StartBERT", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagClient) StopBERT(ctx context.Context, in *StopBERTRequest, opts ...grpc.CallOption) (*StopBERTResponse, error) {
	out := new(StopBERTResponse)
	err := grpc.Invoke(ctx, "/gnoi.diag.Diag/StopBERT", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagClient) GetBERTResult(ctx context.Context, in *GetBERTResultRequest, opts ...grpc.CallOption) (*GetBERTResultResponse, error) {
	out := new(GetBERTResultResponse)
	err := grpc.Invoke(ctx, "/gnoi.diag.Diag/GetBERTResult", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Diag service

type DiagServer interface {
	// Starts BERT operation on a set of ports. Each BERT operation is uniquely
	// identified by an ID, which is given by the caller. The caller can then
	// use this ID (as well as the list of the ports) to stop the BERT operation
	// and/or get the BERT results. This RPC is expected to return an error status
	// in the following situations:
	// - When BERT operation is supported on none of the ports specified by
	//   the request.
	// - When BERT is already in progress on any port specified by the request.
	// - In case of any low-level HW/SW internal errors.
	// The RPC returns an OK status of none of these situations is encountered.
	StartBERT(context.Context, *StartBERTRequest) (*StartBERTResponse, error)
	// Stops an already in-progress BERT operation on a set of ports. The caller
	// uses the BERT operation ID it previously used when starting the operation
	// to stop it. The RPC is expected to return an error status in the following
	// situations:
	// - When there is at least one BERT operation in progress on a port which
	//   cannot be stopped in the middle of the operation (either due to lack of
	//   support or internal problems).
	// - When no BERT operation, which matches the given BERT operation ID, is in
	//   progress or completed on any of the ports specified by the request.
	// - When the BERT operation ID does not match the in progress or completed
	//   BERT operation on any of the ports specified by the request.
	// The RPC returns an OK status of none of these situations is encountered.
	// Note that a BERT operation is considered completed if the device has a
	// record/history of it. Also note that it is OK to receive a stop request for
	// a port which has completed BERT, as long as the recorded BERT operation ID
	// matches the one specified by the request.
	StopBERT(context.Context, *StopBERTRequest) (*StopBERTResponse, error)
	// Gets BERT results during the BERT operation or after it completes. The
	// caller uses the BERT operation ID it previously used when starting the
	// operation to query it. The device is expected to keep the results for
	// last N BERT operations for some amount of time, as specified by the
	// product requirement. This RPC is expected to return error status in the
	// following situations:
	// - When no BERT operation, which matches the given BERT operation ID, is in
	//   progress or completed on any of the ports specified by the request.
	// - When the BERT operation ID does not match the in progress or completed
	//   BERT operation on any of the ports specified by the request.
	// The RPC returns an OK status of none of these situations is encountered.
	// Note that a BERT operation is considered completed if device has a
	// record of it.
	GetBERTResult(context.Context, *GetBERTResultRequest) (*GetBERTResultResponse, error)
}

func RegisterDiagServer(s *grpc.Server, srv DiagServer) {
	s.RegisterService(&_Diag_serviceDesc, srv)
}

func _Diag_StartBERT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBERTRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagServer).StartBERT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.diag.Diag/StartBERT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagServer).StartBERT(ctx, req.(*StartBERTRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diag_StopBERT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopBERTRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagServer).StopBERT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.diag.Diag/StopBERT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagServer).StopBERT(ctx, req.(*StopBERTRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diag_GetBERTResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBERTResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagServer).GetBERTResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.diag.Diag/GetBERTResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagServer).GetBERTResult(ctx, req.(*GetBERTResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Diag_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gnoi.diag.Diag",
	HandlerType: (*DiagServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartBERT",
			Handler:    _Diag_StartBERT_Handler,
		},
		{
			MethodName: "StopBERT",
			Handler:    _Diag_StopBERT_Handler,
		},
		{
			MethodName: "GetBERTResult",
			Handler:    _Diag_GetBERTResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "diag/diag.proto",
}

func init() { proto.RegisterFile("diag/diag.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1028 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0xda, 0x4e, 0x1a, 0x9f, 0xfc, 0x78, 0x33, 0x21, 0xa9, 0xe3, 0x40, 0xeb, 0xb8, 0x85,
	0x9a, 0x14, 0xdc, 0xc4, 0x11, 0x42, 0xe5, 0x02, 0x69, 0x1d, 0x6f, 0x92, 0x55, 0xdc, 0xdd, 0xd5,
	0xec, 0x9a, 0x92, 0x5e, 0x30, 0xda, 0x38, 0xd3, 0xd4, 0x74, 0xed, 0x5d, 0x66, 0xc6, 0x17, 0x7d,
	0x00, 0xc4, 0x05, 0xe2, 0x61, 0x78, 0x0d, 0xae, 0x10, 0x3c, 0x07, 0xaf, 0x80, 0xd0, 0x8c, 0xed,
	0x78, 0x6d, 0xd9, 0x09, 0x09, 0x12, 0xea, 0xcd, 0x4a, 0x73, 0xbe, 0xef, 0xec, 0x39, 0xe7, 0x3b,
	0x67, 0x7e, 0x20, 0x77, 0xd1, 0x0e, 0x2e, 0x9f, 0xc9, 0x4f, 0x25, 0x66, 0x91, 0x88, 0x50, 0xf6,
	0xb2, 0x1b, 0xb5, 0x2b, 0xd2, 0x50, 0x58, 0x13, 0xef, 0x62, 0xca, 0x9f, 0xa9, 0x6f, 0x1f, 0x2d,
	0xfd, 0x96, 0x02, 0xdd, 0x13, 0x01, 0x13, 0x35, 0x13, 0xfb, 0x98, 0xfe, 0xd0, 0xa3, 0x5c, 0xa0,
	0x5d, 0x58, 0x3b, 0xa7, 0x4c, 0x90, 0x28, 0xa6, 0x2c, 0x10, 0xed, 0xa8, 0x4b, 0xda, 0x17, 0x79,
	0xad, 0xa8, 0x95, 0xb3, 0x38, 0x27, 0x01, 0x67, 0x68, 0xb7, 0x2e, 0xd0, 0x37, 0xb0, 0x16, 0x53,
	0x46, 0xe2, 0x88, 0x09, 0xc2, 0xfa, 0xfe, 0x3c, 0x9f, 0x2a, 0xa6, 0xcb, 0x4b, 0xd5, 0xdd, 0xca,
	0x55, 0xe8, 0xca, 0x64, 0x8c, 0x8a, 0x4b, 0x99, 0x1b, 0x31, 0x31, 0x58, 0xe2, 0x5c, 0x3c, 0xb6,
	0xe6, 0x85, 0x5f, 0x35, 0x58, 0x1d, 0xe7, 0xa0, 0x32, 0x64, 0xdb, 0x5d, 0x41, 0xd9, 0xeb, 0xa0,
	0x45, 0x55, 0x3a, 0x4b, 0x55, 0xe8, 0x87, 0x70, 0x03, 0xf1, 0x06, 0x8f, 0x40, 0x54, 0x83, 0x5c,
	0xcc, 0xce, 0x39, 0x89, 0xa3, 0xf0, 0x5d, 0x37, 0xea, 0xb4, 0x83, 0x30, 0x9f, 0x2a, 0x6a, 0xe5,
	0xd5, 0xea, 0x56, 0x22, 0x25, 0x97, 0x9d, 0x73, 0xf7, 0x8a, 0x80, 0x57, 0xe3, 0xb1, 0x35, 0xda,
	0x87, 0x0d, 0x41, 0xb9, 0x20, 0x17, 0xbd, 0xa1, 0x06, 0x5d, 0xc2, 0x69, 0x8b, 0xe7, 0xd3, 0x45,
	0xad, 0xbc, 0x82, 0x91, 0x04, 0xeb, 0x03, 0xcc, 0xea, 0x7a, 0xb4, 0xc5, 0x4b, 0x3f, 0xa5, 0x60,
	0x2d, 0x51, 0x28, 0x8f, 0xa3, 0x2e, 0xa7, 0xb7, 0x52, 0xf3, 0x15, 0xa0, 0x84, 0x9a, 0xfd, 0x1f,
	0x0c, 0xe5, 0xfc, 0x6c, 0xba, 0x9c, 0x7d, 0xd2, 0x48, 0xcf, 0xfe, 0x1a, 0xeb, 0xf1, 0xb8, 0x81,
	0x17, 0xbe, 0x87, 0xdc, 0x04, 0xe9, 0x16, 0x8a, 0x7e, 0x0e, 0x0b, 0x5c, 0x04, 0xa2, 0xc7, 0x07,
	0x42, 0x6e, 0x24, 0x92, 0xa9, 0x51, 0x26, 0x3c, 0x05, 0xe2, 0x01, 0xa9, 0xf4, 0xbb, 0x06, 0x39,
	0x4f, 0x44, 0xf1, 0x5d, 0xa7, 0xaa, 0x39, 0x7b, 0xaa, 0x3e, 0x1d, 0x93, 0x61, 0x2c, 0xc4, 0x8d,
	0x43, 0xf5, 0xd5, 0xdd, 0x67, 0xaa, 0xf4, 0xa3, 0xda, 0x29, 0xc3, 0x78, 0x77, 0xe8, 0xed, 0xd9,
	0x35, 0xbd, 0x7d, 0x3a, 0xb5, 0xa8, 0xf7, 0xb2, 0xb5, 0xbf, 0xa4, 0xe0, 0x83, 0x63, 0x3a, 0x1c,
	0xbe, 0x5e, 0x28, 0xee, 0xd2, 0xdf, 0x57, 0xb3, 0xfb, 0x5b, 0x49, 0x84, 0x9f, 0x16, 0xe7, 0xa6,
	0x26, 0xcb, 0x8d, 0xcb, 0x94, 0x03, 0x79, 0xcd, 0xa2, 0x0e, 0x09, 0xc2, 0x50, 0xc5, 0xe9, 0x6f,
	0xdc, 0x45, 0x8c, 0xfa, 0xe0, 0x11, 0x8b, 0x3a, 0x46, 0x18, 0x4a, 0xcf, 0xff, 0x38, 0x17, 0xf3,
	0xb0, 0x31, 0x91, 0xe7, 0xa0, 0x05, 0xdf, 0x4d, 0x6d, 0xb8, 0xa6, 0xaa, 0xdc, 0x9b, 0x5d, 0xe5,
	0xbf, 0xee, 0xfa, 0xcf, 0x99, 0xff, 0xaf, 0xed, 0xd3, 0xbb, 0x9b, 0x9e, 0xde, 0xdd, 0x29, 0xc7,
	0x6f, 0xe6, 0xb6, 0xc7, 0xef, 0x73, 0xd8, 0x0a, 0x03, 0x2e, 0x88, 0x0a, 0xca, 0xe5, 0x71, 0x47,
	0x44, 0xbb, 0x43, 0xb9, 0x08, 0x3a, 0x71, 0x7e, 0xbe, 0xa8, 0x95, 0x33, 0x78, 0x53, 0x12, 0x06,
	0xa9, 0x32, 0xe1, 0x0f, 0x51, 0x54, 0x83, 0x07, 0x23, 0xd7, 0x4b, 0xaa, 0xc4, 0x97, 0xe3, 0x30,
	0xf2, 0x5f, 0x50, 0xfe, 0x85, 0xa1, 0xff, 0x31, 0x15, 0x7d, 0xf1, 0x47, 0xff, 0xa8, 0xc2, 0x46,
	0x4c, 0x29, 0x23, 0x61, 0xd4, 0x7a, 0x4b, 0xa4, 0xed, 0x3c, 0x6c, 0xf3, 0x37, 0xf4, 0x22, 0x7f,
	0x4f, 0x0d, 0xd1, 0xba, 0x04, 0x1b, 0x51, 0xeb, 0xad, 0x39, 0x82, 0xd0, 0x63, 0x58, 0x1d, 0xf9,
	0x84, 0x11, 0x17, 0xf9, 0x45, 0x45, 0x5e, 0x1e, 0x92, 0x1b, 0x11, 0x17, 0xe8, 0x00, 0x36, 0x29,
	0x63, 0x11, 0x23, 0xad, 0xa8, 0xd7, 0x15, 0x44, 0x4e, 0x48, 0xa7, 0xdd, 0xed, 0x09, 0x9a, 0xcf,
	0x16, 0xd3, 0xe5, 0x15, 0xbc, 0xae, 0xd0, 0x43, 0x09, 0xba, 0x94, 0xbd, 0x50, 0x10, 0xda, 0x81,
	0x65, 0x11, 0x89, 0x20, 0x24, 0x0a, 0xe4, 0x79, 0x50, 0x05, 0x2c, 0x29, 0x9b, 0xa9, 0x4c, 0xbb,
	0x7f, 0xca, 0x0b, 0x73, 0x5c, 0xc3, 0x6d, 0xb8, 0xef, 0xe2, 0x9a, 0x47, 0x5c, 0xa7, 0x71, 0x66,
	0x3b, 0x2f, 0x2c, 0xa3, 0x41, 0x9a, 0xf6, 0xa9, 0xed, 0xbc, 0xb4, 0xf5, 0x39, 0xb4, 0x05, 0x1b,
	0x93, 0xa0, 0x5c, 0x7f, 0xa9, 0x6b, 0xb3, 0xa0, 0xe7, 0x7a, 0x0a, 0x15, 0x60, 0x73, 0x1a, 0xb4,
	0xff, 0x85, 0x9e, 0x9e, 0x85, 0x55, 0xf7, 0xf4, 0xcc, 0x4c, 0xec, 0x40, 0x9f, 0x9f, 0x85, 0x1d,
	0xec, 0xeb, 0x0b, 0xbb, 0x7f, 0xa7, 0x01, 0x46, 0xd3, 0x88, 0xee, 0xc3, 0xba, 0xdc, 0x2a, 0xc4,
	0xf3, 0x0d, 0xbf, 0xe9, 0x25, 0xaa, 0x41, 0xb0, 0x9a, 0x04, 0x9c, 0x53, 0x5d, 0x43, 0x3b, 0xf0,
	0x51, 0xd2, 0x66, 0x3b, 0x36, 0x31, 0xbf, 0xb5, 0x3c, 0xdf, 0xb4, 0x7d, 0xe2, 0x3a, 0xd8, 0xd7,
	0x53, 0xe8, 0x63, 0xd8, 0x49, 0x52, 0x4e, 0x0c, 0x5c, 0x7f, 0x69, 0x60, 0x93, 0x18, 0x87, 0x87,
	0xa6, 0xe7, 0x11, 0x13, 0x63, 0x07, 0xeb, 0x69, 0xf4, 0x14, 0x9e, 0x8c, 0x87, 0xf5, 0x9a, 0xae,
	0xfc, 0x83, 0x59, 0x27, 0x13, 0x99, 0xeb, 0x19, 0xf4, 0x18, 0x8a, 0x49, 0xb2, 0xe4, 0x11, 0xa3,
	0x81, 0x4d, 0xa3, 0x7e, 0x46, 0x2c, 0x9b, 0x48, 0x4c, 0x9f, 0x9f, 0x8c, 0xac, 0x58, 0xb6, 0xe3,
	0x13, 0xdc, 0xb4, 0x6d, 0xcb, 0x3e, 0xee, 0xd3, 0x16, 0xd0, 0x13, 0x78, 0x94, 0xa4, 0xf9, 0xa6,
	0xe7, 0x93, 0x7a, 0x13, 0x1b, 0xbe, 0xe5, 0xd8, 0xc4, 0x77, 0x1c, 0xe2, 0x9d, 0xc8, 0x4a, 0xee,
	0xa1, 0x4f, 0xa0, 0x74, 0x3d, 0xb1, 0xe1, 0xd8, 0xc7, 0xfa, 0xe2, 0x24, 0xcf, 0x71, 0xcd, 0x01,
	0xc7, 0xaa, 0xab, 0xf8, 0x47, 0x4e, 0xd3, 0xae, 0xeb, 0x59, 0xf4, 0x08, 0x1e, 0xce, 0xe4, 0x59,
	0x36, 0x69, 0x7a, 0xa6, 0x0e, 0x93, 0x0a, 0xbb, 0xa6, 0x89, 0x49, 0xc3, 0x39, 0x3c, 0x25, 0x47,
	0x86, 0xd5, 0x68, 0x62, 0x53, 0x5f, 0x42, 0x0f, 0xa0, 0x30, 0x9d, 0xd2, 0x70, 0x3c, 0x5f, 0x5f,
	0x9e, 0xc4, 0x2d, 0xdb, 0x37, 0xb1, 0x6d, 0x34, 0x06, 0xd2, 0xaf, 0x54, 0xff, 0xd2, 0x20, 0x53,
	0x6f, 0x07, 0x97, 0xe8, 0x04, 0xb2, 0x57, 0xaf, 0x1e, 0xb4, 0x7d, 0xcd, 0xd3, 0xb2, 0xf0, 0xe1,
	0x75, 0x0f, 0xa5, 0xd2, 0x1c, 0x32, 0x61, 0x71, 0x78, 0xc7, 0xa2, 0xc2, 0xec, 0xd7, 0x44, 0x61,
	0xfb, 0x9a, 0x4b, 0xb9, 0x34, 0x87, 0x7c, 0x58, 0x19, 0x3b, 0xb9, 0xd1, 0xc3, 0x1b, 0x6e, 0xae,
	0x42, 0xf1, 0xa6, 0x43, 0xbf, 0x34, 0x57, 0x5b, 0xfc, 0xe3, 0xeb, 0xf9, 0xbd, 0xca, 0x7e, 0x65,
	0xef, 0x7c, 0x41, 0xbd, 0xd0, 0x0f, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0xd7, 0x6b, 0x04, 0xbd,
	0xd2, 0x0b, 0x00, 0x00,
}
